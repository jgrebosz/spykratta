//---------------------------------------------------------------
//        Go4 Framework release package V.1.0000
//                      24-May-2002
//---------------------------------------------------------------
//  The GSI Online Offline Object Oriented (Go4) Project
//  Experiment Data Processing at DVEE department, GSI
//---------------------------------------------------------------
//
//Copyright (C) 2000- Gesellschaft f. Schwerionenforschung, GSI
//                    Planckstr. 1, 64291 Darmstadt, Germany
//Contact:            http://go4.gsi.de
//----------------------------------------------------------------
//This software can be used under the license agreements as stated
//in Go4License.txt file which is part of the distribution.
//----------------------------------------------------------------
/* Generated by Together */

#include "TIFJAnalysis.h"
#include "spectrum.h"
using namespace std;
#include <sstream>

#include "TIFJCalibrateProcessor.h"


//#include <Go4Event/TGo4EventSourceParameter.h>
//#include <TGo4MbsFileParameter.h>

//#include "Go4Event/TGo4EventProcessor.h"
//#include "Go4EventServer/TGo4RevServParameter.h"



//#include "Go4Event/TGo4EventErrorException.h"
//#include "Go4Event/TGo4EventTimeoutException.h"
//#include "Go4Event/TGo4EventEndException.h"

#include "Tcracow_exception.h"
#include "Tnamed_pointer.h"
#include <string>
#include <fcntl.h>
#include "user_spectrum_description.h"
#include "Tuser_spectrum.h"
#include "Tuser_condition.h"
#include "Tcondition_description.h"

#include "Tcate.h"
#include "Tcate_telescope.h"

#include "Tuser_incrementer.h"
#include "Tfile_helper.h"

// Joern Adamczewski suggest to definie it here and refer as extern
// from MainUserAnalysis
//    (it was other way round before)
bool go4_gui_mode;  // Take does not want to save *.spc files in Go4 mode

//#define COTO  cout<<" I am at line  "<<__LINE__<< endl;
#define ANYKEY { int nic; cout << "press 1 and Enter " << endl; cin >> nic;}


TIFJCalibratedEvent * TIFJAnalysis::fxCaliEvent;   // static
TIFJAnalysis *RisingAnalysis_ptr;

extern unsigned int starting_event; // global to be set in main and accessed from constructor of TGo4Analysis.cxx

//****************************************************************************
TIFJAnalysis::TIFJAnalysis()
    :
    //fxUserFile(0),
    fxMbsEvent(0), fxEbEvent(0)      // ,fxCaliEvent(0)
#ifdef GSI_STUFF
    , synchro_watchdog("synchronisation_watchdog")
#endif // ifdef GSI_STUFF
    , frs(this)
{
    // disabled default ctor JA
}
//****************************************************************************
TIFJAnalysis::TIFJAnalysis(
    string  nam1,
    string  nam2,
    string  nam3,
    string  nam4)  :
    // fxUserFile(0),
    fxMbsEvent(0), fxEbEvent(0)      // ,fxCaliEvent(0)
#ifdef GSI_STUFF
    , synchro_watchdog("synchronisation_watchdog")
#endif //ifdef GSI_STUFF

    //! trick, that allows to have separate version of frs_calibration.txt for PISOLO i EXOTIC
#if CURRENT_EXPERIMENT_TYPE==PISOLO2_EXPERIMENT
    , frs(this, "pisolo")
#elif CURRENT_EXPERIMENT_TYPE   ==    EXOTIC_EXPERIMENT
    , frs(this , "exotic")
#elif CURRENT_EXPERIMENT_TYPE   ==    PRISMA_EXPERIMENT
    , frs(this , "prisma")              // offical name, it will be used to construct the name of the calibration file
#elif CURRENT_EXPERIMENT_TYPE   ==    IFJ_KRATTA_HECTOR_EXPERIMENT
    , frs(this , "ccb")              // offical name, it will be used to construct the name of the calibration file
#else
    , frs(this)        // default argument is "frs"
#endif
{

    RisingAnalysis_ptr = this;
    general_flag_verbose_events = false;
    nr_events_analysed = 0 ;
    print_ratios_every_n_events = 5000;
    previous_print_ratios_time = time(NULL);
    previous_print_event_nr = 0 ;


    //    source_of_events = NULL; // will be defined below

    // nam1: input file name (*.lmd)
    // nam2: output file name of first analysis step  (*.root)
    // nam3: output file name of second analysis step (*.root)
    // nam4:
    ntuple_RAW_is_collected = false;
    ntuple_CAL_is_collected = false;

    info_to_cracow("Spy is going to start soon...");


    //=========================================================
    // first step definitions:
    //=========================================================
#ifdef BEZGO4
#else

    flag_sorting_from_file = false;  // later we set it really

//     char ptr1[250] = "currrent.lmd";
//     char ptr2[250] = "currrent_RAW_tree";   // was ASF by mistake
//     char ptr3[250] = "currrent_CAL_tree";


    // look at the first argument
    string kawalek = string(nam1).substr(0, 4);       // "-remserver"


    // if it is "-rem" the data will come online from the experiment.  +++++++++++++++
    if(kawalek == "-rem")      // "-remote-event-server"
    {
        //      from the server - whien this is nr of port
        cout << "before connecting " << endl;
        source_of_events = new TGo4RevServParameter(nam2, nam3);      // online
        cout << "after connecting " << endl;
    }
    else     // data will come from the disk file, normally ++++++++++++++++
    {
        flag_sorting_from_file = true; // important for timeout
        // TGo4MbsFileParameter*
        source_of_events = new TGo4MbsFileParameter(nam1);
        cout << "starting event  ===============" << starting_event << endl;

        ((TGo4MbsFileParameter*) source_of_events)->SetStartEvent(starting_event);
    }
    cout << "Connection with the source of events - established." << endl;

    //__________________ input data - established successfuly -------------------------

    // STEP 1
    TIFJEventProcessor* procpar1 = new TIFJEventProcessor ;
    TIFJCalibrateProcessor* procpar2 = new TIFJCalibrateProcessor;

    TIFJEvent *evptr1  =  new TIFJEvent;

    // cout << "After creating the object in address" << evptr1 << endl;



    TIFJCalibratedEvent * evptr2 =  new TIFJCalibratedEvent;

    set_all_steps(procpar1, procpar2,
                  evptr1,
                  evptr2);

#endif

    //================================================

    //////// open user file (optional)
    //  strcat(nam4,".root");
    //  fxUserFile = new TFile(nam4,"RECREATE");
    //  fxUserFile->SetCompressionLevel(5);
    //  gROOT->cd();

    // my stuff ///////////////////

    create_my_spectra();
    restore_times_of_zeroing_from_disk();

}
//*****************************************************************************
/** No descriptions */
void TIFJAnalysis::create_my_spectra()
{
    // constructing the "spectra" for timestammps

}
//*****************************************************************************
TIFJAnalysis::~TIFJAnalysis()
{

    //  cout<< "***** EbAnalysis: destructor writing things to file... ***** "
    // <<endl;

    for(unsigned int i = 0 ; i < list_of_histograms.size() ; i++)
    {
        delete  list_of_histograms[i];
    }

    for(unsigned int i = 0 ; i < list_of_polygons.size() ; i++)
    {
        delete  list_of_polygons[i];
    }

    for(unsigned int i = 0 ; i < spectra_user.size() ; i++)
    {
        delete  spectra_user[i];
    }

    for(unsigned int i = 0 ; i < user_condition.size() ; i++)
    {
        delete  user_condition[i];
    }

    //   for (unsigned  int i = 0 ; i < vector_of_user_incrementers.size() ; i++ )
    //     {
    //      delete  vector_of_user_incrementers[i];
    //     }




    for(unsigned int i = 0 ; i < spectra_local.size() ; i++)
    {
        delete  spectra_local[i];
    }

    delete source_of_events ;

    delete  step1;
    delete  step2;

    //    cout << "Before deleting the object in address" << step1_output_event << endl;
    delete  step1_output_event;
    delete  step2_output_event;

    step1 =  0;
    step2 = 0;
    step1_output_event = 0;
    step2_output_event = 0 ;


    //////// handle optional user file:
    //  if(fxUserFile)
    //    {
    //      cout<< "***** write to userfile... ***** "<<endl;
    //      fxUserFile->cd();
    //
    //      delete fxUserFile;
    //      cout<< "***** deleted userfile... ***** "<<endl;
    //      fxUserFile=0;
    //      gROOT->cd();
    //    }


    ////////////////////////////////////////////////////////////////////////////
    // note: objects registered in analysis ctor must not be removed
    // if they shall saved in autosave file
    // autosave in TGo4Analysis dtor will be performed _after_ this dtor
    // therefore the removed objects will disappear in file!

    ///////////////////////////////////////////////////////////////////////////


    // jurek stuff


    // removing spectra, to late now ?



    //-------------------------------------------------------
    //cout << " transoprter was REGISTERED so we shouldn't delete it !"
    // << endl;
    //delete ptr_transporter;
    // ptr_transporter = 0;
    //-------------------------------------------------------



    //cout<< "***** EbAnalysis: End of destructor  ***** "<<endl;
    //  cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
    //  "Note: If you have the 'Segment Violation' error, you may have to delete the *.root file\n"
    //  "It often helps \n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    //"\nJurek, perhaps you deleted some object which was registered?\n\n"
    //  << endl;
}
//****************************************************************************
int TIFJAnalysis::UserPreLoop()
{
    //// This function is processed once before the implicit loop.
    //// For online (gui-mode), it is called on every start of the analysis
    cout << "***** EbAnalysis: User Preloop ***** " << endl;

    info_to_cracow("Spy is reading current parameters");

    // we update the pointers to the current event structurese here:

#ifdef NOGO4

    fxMbsEvent = dynamic_cast<TGo4MbsEvent*>(GetInputEvent("Unpack"));
    fxEbEvent = dynamic_cast<TIFJEvent*>(GetOutputEvent("Unpack"));
    fxCaliEvent = dynamic_cast<TIFJCalibratedEvent*>(
                      GetOutputEvent("Calibrate"));
#endif



    // jurek
    //   cout << "Rezerwacja obiektow Event" << endl;
    fxMbsEvent = 0 ; //new TGo4MbsEvent;
    fxEbEvent =   step1_output_event;
    fxCaliEvent = step2_output_event;


    ptr_to_mbs_nr_of_the_current_event =
        step1->give_address_of_mbs_event_number();

        // tree - ntuple - must be before hector, kata - bec it is reading the option from the file
     read_ntuple_options();
    /*
        for ( int i = 0 ; i < steps_of_analysis.size() ; i++ )
        {
            steps_of_analysis[i]-> call_preLoop(); // to read lookup table
        }

        */

    // here we can sent pointers to the frs class
    frs.make_frs_preloop_action(fxEbEvent , fxCaliEvent);

#ifdef HECTOR_PRESENT
    hector.make_preloop_action (fxEbEvent , fxCaliEvent);
#endif


#ifdef USER_INCREMENTERS_ENABLED

    // read in the definition of user incrementers
    read_in__user_incrementers();
    cout << "Successfuly defined incrementers..." << endl;

    // *user incrementer as well
    for(auto x : vector_of_user_incrementers)
    {
        cout  << *x  << endl;
    }


#endif // #ifdef USER_INCREMENTERS_ENABLED

    //################################################
    // storing list of names of variables for cracow Wizard
    ofstream plik("commands/list_of_variables.txt");
    ofstream plikselfgates("commands/list_of_variables_with_selfgates.txt");
    Tmap_of_named_pointers::iterator pos;
    for(pos = named_pointer.begin(); pos != named_pointer.end(); ++pos)
    {

        plik << pos->first << endl;
//         cout << pos->first << " odpowiada_adres " << ( reinterpret_cast<long> (&(pos->second) )) << endl;

        auto drugi = pos->second ;
//         cout << "UserPreLoop()   drugi " << drugi.what_type << endl;
        if(pos->second.ptr_detector != nullptr)
        {
            if(pos->second.ptr_detector->selfgate_type_is_not_avaliable() == false  )
            {
                plikselfgates
                        << pos->first 					// name of incremener
                        << "     "
                        << static_cast<int>(pos->second.ptr_detector->give_selfgate_type()) // code of enum
                        << endl;
            }
        }

    }
    // *user incrementer as well
//     for(auto x : vector_of_user_incrementers)
//     {
//         plik << x << endl;
//     }

    plik.close();
    plikselfgates.close();


    //  read_in_verbose_parameters();     // for listing someof the events

    read_autosave_time();  // and so called -other options

    // adding my user spectra h-----------------
    read_definitions_of_user_spectra();


    cout << "\nAfter finishing to define the spectra, there are such conditions"
         << endl;
    for(unsigned i = 0; i < user_condition.size(); i++)
    {
        cout << i << ") " <<  user_condition[i]->give_name() << endl;
    }

    //  for(unsigned i = 0; i < sorting_wish.size(); i++)
    //  {
    //    sorting_wish[i]->preloop_time();
    //  }

   
    prepare_ntuple_addition();
    prepare_ratio_vector();

    //     cycle_on_real_data = false;  // initially


    return 0;

}
//****************************************************************************
int TIFJAnalysis::UserPostLoop()
{
    //// This function is processed once after the implicit loop.
    //// For online (gui-mode), it is called on every stop of the analysis
    cout << "***** EbAnalysis: User Postloop ***** " << endl;

    {
        // if this is batch (also cracow) mode
        time_t begin  = time(0);
        frs.make_postloop_action();

#ifdef HECTOR_PRESENT
        hector.make_postloop_action();
#endif

        time_t end = time(0);
        cout << "Saving spectra took " << end - begin << " seconds " << endl;
    }


    /*
        for ( int i = 0 ; i < steps_of_analysis.size() ; i++ )
        {
            steps_of_analysis[i]-> postLoop(); // to read lookup table
        }
    */


    // user defined spectra --------------------
    for(unsigned i = 0; i < spectra_user.size(); i ++)
    {
        flag_talking_histograms = true;
        spectra_user[i]->save_to_disk();
        flag_talking_histograms = false ;
    }


    // my replacement of Go4

    //     cout << "Kasowanie obiektow Event" << endl;
    delete fxMbsEvent;
    fxMbsEvent = 0; // reset to avoid invalid pointer if analysis is changed in between

    //   delete fxEbEvent;
    // fxEbEvent = 0 ;


    //   delete fxCaliEvent;
    //    fxCaliEvent = 0;

    proc_remembered = 0;

    return 0;
}

//*****************************************************************************
int TIFJAnalysis::UserEventFunc()
{


    //// This function is called once for each event.
    //// In addition to the event processor operations, eventwise analysis
    //// can be done here

    //      cout<< "***** EbAnalysis: User Event Func ***** "<<endl;



    // fill user histograms:
//     int value = 0;

    // user defined spectra --------------------
    //  if ( cycle_on_real_data )
    {
        //         cout << "New event check ================================" << endl;


        // Here was the check of the user defined conditions. Now it is as a special function
        // called
        //           check_all_user_def_conditions()
        // and it is called earlier, on the end of the step2, because we need to know the result
        // earlier, just before storing the data in the n-tuple


        for(unsigned i = 0; i < spectra_user.size(); i ++)
        {
//                             cout << "Working with the user spectrum nr " << i
//                             << " called " << spectra_user[i]->give_name()
//                             << endl;
            spectra_user[i]->make_incrementations();
        }


        make_ratio_spectra();
    }
    //     cycle_on_real_data = false;
    return 0;
}

//****************************************************************************
bool TIFJAnalysis::InitEventClasses()
{
    // cout << "fcja Initevent classes =======calling inheritated ====== "
    // << endl;

    return 777;
}
//****************************************************************************


//*****************************************************************************
void TIFJAnalysis::CloseAnalysis()   // hiding the one from the base class
{
    // calling the base class version
    //  TGo4Analysis::CloseAnalysis();

    //cout << "- After   TGo4Analysis::CloseAnalysis(),
    // JUREK -----My, empty  version of Close Analysis ------" << endl;

}

//*****************************************************************************
TIFJCalibrateProcessor* TIFJAnalysis::give_call_processor_address()
{
    //cout << "Trying to acquire the current address of the callibration processor "
    //     << endl;
    //  fxCaliEvent=dynamic_cast<TIFJCalibratedEvent*> ( GetOutputEvent("Calibrate") );
    //   cout << " after funtion   GetOutputEvent(Calibrate) "<< endl;

    return 0;
}
//***************************** when **********************************************
#if 0
/** this is such a version which replaces the RunImplicitLoop,
  but is able to handle the pause and continue exceptions */
int TIFJAnalysis::run_jurek_ImplicitLoop(int times)
{

    const long int infinity = 999999999L;

    if(times == 0)
    {
        times = infinity; // was bug in go4
    }
    // automatic resources =====================================================
    class spy_works
    {

        string nazwa;
    public:
        spy_works()
        {
            nazwa = "commands/spy_works.command";
            ofstream plik(nazwa.c_str());
            plik << "running" << endl;
            plik.close();
        }
        void running(bool flag_running)
        {
            ofstream plik(nazwa.c_str());
            plik << (flag_running ? "running" : "paused")  << endl;
            plik.close();
        }

        ~spy_works()
        {
            remove
            (nazwa.c_str());
        }
    };

    spy_works automatic;


    //=========================================================================

    bool flag_pause = false;

    int curr_ev_nr = 0; // number of actually processed events
    try
    {
        user_batch();
        PreLoop();

        //         Message ( 0,"G-OOOO-> Analysis Implicit Loop for %d cycles is starting... <-OOOO-G",
        //                   times );

        int  last_ev_mbs_long_term_nr = 0;
        int  last_ev_analsyed_long_term_nr = 0;


        //times = 4;  // for testing
        for(curr_ev_nr = 0; curr_ev_nr < times  || (curr_ev_nr == infinity); ++curr_ev_nr)
        {
            if(curr_ev_nr == infinity) curr_ev_nr = 0 ;

            try
            {
                // here we could check if there are some spectra to delete
                perhaps_delete_some_spectra();
                check_for_commands(curr_ev_nr);
                save_just_observed(); // only the selected spectra just observed in cracow


                // ------------ in PAUSED state ------------------
                if(flag_pause)
                {
                    --curr_ev_nr;
                    // how often to look at the disk

                    static time_t last = time(0);
                    time_t now = time(0);
                    if(now - last > 3)
                    {
                        last = now;
                        // check on the disk for the command "continue"
                        string nazwa = "commands/spy_continue.command";
                        ifstream plik(nazwa.c_str());
                        if(plik)
                        {
                            info_to_cracow(" prepares to run again");
                            remove
                            (nazwa.c_str());
                            PreLoop();
                            flag_pause = false;
                            cout << "continue the analysis" << endl;
                            plik.close();
                            remove
                            (nazwa.c_str());    // second time, to be sure, because prelop takes time
                            automatic.running(true);

                            last_ev_mbs_long_term_nr =  0;
                            last_ev_analsyed_long_term_nr = curr_ev_nr;

                            info_to_cracow("Spy prepares to run again");

                        }
                        else
                        {
                            cout << "Spy paused by the cracow viewer request" << endl;
                            info_to_cracow(" is PAUSED  on ", curr_ev_nr);
                        }
                    }
                } //----------------------------- end if flag pause
                else
                {

                    /** Flag telling that now we want to dump information
                    about the current event */
                    //     if(verbose_mode_enabled)
                    //     {
                    //      if(i >= verbose_begins_with_event_nr
                    //        &&
                    //        i < (verbose_begins_with_event_nr + verbose_how_many_events)
                    //        )
                    //             {
                    //             flag_verbose_events = true;
                    //             // cout << "======= CyEvent nr " << i << " verbose listing =========" << endl;
                    //             // i is not an event nr. Events are those which pass to the calibration step.
                    //             }
                    //       else
                    //         { flag_verbose_events = false;}
                    //     }
                    perhaps_conditions_report();

                    MainCycle();

                    perhaps_info_of_events(curr_ev_nr);

                    //============== RATIO DISPLAY ===============
                    static int print_ratios_every_n_events = 5000;
                    static time_t previous_print_ratios_time = time(NULL);
                    static int previous_print_event_nr = 0 ;

                    if(!(curr_ev_nr % print_ratios_every_n_events))
                    {
                        static int previously_displayed_ev_mbs_nr = 0;
                        time_t now = time(NULL);



                        if(previously_displayed_ev_mbs_nr != 0)      // to avoid first print
                        {
                            static time_t  speed_ratio__time_before = 0;
                            cout << "\n--- Read " << curr_ev_nr << " SUBevents ";


                            double recent_ratio =
                                (100 * (curr_ev_nr - previous_print_event_nr))
                                /
                                ((*ptr_to_mbs_nr_of_the_current_event) - previously_displayed_ev_mbs_nr);


                            double ratio_long_term =
                                (100 * (curr_ev_nr - last_ev_analsyed_long_term_nr))
                                /
                                ((*ptr_to_mbs_nr_of_the_current_event) - last_ev_mbs_long_term_nr);


                            // Long term statistics
                            if(last_ev_mbs_long_term_nr != 0)
                            {


                                cout
                                        << ", (ratio "
                                        << ratio_long_term << "% "
                                        << " of all coming)"
                                        << "   [recently " << recent_ratio
                                        << "%]   ";

                                //--- speed ---------------------
                                static int previous_speed_event_nr = 0;
                                int speed__time_diff = now - speed_ratio__time_before;
                                int how_many_seconds_to_calculate_speed = 2;

                                if(speed__time_diff >= how_many_seconds_to_calculate_speed)
                                {

                                    double speed = (1.0 * (curr_ev_nr - previous_speed_event_nr) / speed__time_diff);
                                    if(speed > 1)
                                    {
                                        cout
//                    <<  "(curr_ev_nr - previous_print_event_nr)= " <<  (curr_ev_nr - previous_print_event_nr)
//          << " how_many_seconds_to_calculate_speed=" << how_many_seconds_to_calculate_speed
//           <<  " diff=" <<  speed_ratio__time_diff
//            << "\n  ( 1.0 * (curr_ev_nr - previous_print_event_nr) /diff )     "
                                                << (1.0 * (curr_ev_nr - previous_speed_event_nr) / speed__time_diff)
                                                << " ev/s ";
                                    }
                                    speed_ratio__time_before = now;
                                    previous_speed_event_nr = curr_ev_nr;
                                }
                                else
                                {
                                    //cout << " speed_ratio__time_diff " << speed__time_diff << endl;
                                }

                                int since_last_display = now - previous_print_ratios_time;
                                if(since_last_display < 2)      // every n seconds
                                {
                                    //print_ratios_every_n_events += 3000;
                                    print_ratios_every_n_events *= 2;
                                    //cout << "----------Mult Changed print_every_n_events, now is " << print_ratios_every_n_events << endl;
                                }
                                else if(since_last_display < 10)        // every n seconds
                                {
                                    print_ratios_every_n_events += 3000;
//                                  print_ratios_every_n_events *= 2;
//                                  cout << "----------Added  print_every_n_events, now is " << print_ratios_every_n_events << endl;
                                }

                                previous_print_event_nr = curr_ev_nr;
                                previous_print_ratios_time = now;

                                if(ntuple_RAW_is_collected)
                                {
                                    cout << "\nNote: The option to produce the n-tuple file  (*_RAW_tree.root) is  ON.";
                                }
                                if(ntuple_CAL_is_collected)
                                {
                                    cout << "\nNote: The option to produce the n-tuple file  (*_CAL_tree.root) is  ON.";
                                }

                            }
                            else
                            {
                                last_ev_mbs_long_term_nr =  *ptr_to_mbs_nr_of_the_current_event;
                                last_ev_analsyed_long_term_nr = curr_ev_nr;
                            }

                            cout  << endl;


                        } // endif how often display rates

                        previously_displayed_ev_mbs_nr = *ptr_to_mbs_nr_of_the_current_event;

                    } // endif else --- > not pause, so running
                    //=============================================

                    static time_t   time_last = time(0);    // so always at first save

                    time_t  time_now = time(0);

                    if(time_now - time_last > (autosave_period_in_minutes * 60))
                    {
                        info_to_cracow(" makes autosave");
                        PostLoop();
                        cout << "Autosave from  - finished (every " << autosave_period_in_minutes
                             << " minutes)" << endl;
                        time_last = time_now;
                        info_to_cracow(" finished autosave");
                    }

                    //save_just_observed(); // only the selected spectra just observed in cracow

                } // end else --- not paused

            } // end try
            //-------------------------

            //----------------------------
            catch(Tcracow_exception & kkk)
            {
                if(kkk.message == "pause")
                {
                    info_to_cracow("is PAUSED  on ", curr_ev_nr);
                    PostLoop();
                    flag_pause = true;
                    automatic.running(false);
                }
                else
                {
                    perhaps_conditions_report(true);    // parforce
                    throw;  // probably 'finish'
                }
            }
            //----------------------------
            //----------------------------
            catch(std::bad_alloc & ex)      // treat standard library exceptions
            {

                cout << "ERROR: Not enough memory to reserve the spectrum! " << endl;
                //                 Message ( 0,"G-OOOO-> (1.9) bad_alloc exception %s appeared after %d cycles.  <-OOOO-G",
                //                           ex.what(), i );
            }
            catch(std::exception& ex)        // treat standard library exceptions
            {

                //                 Message ( 0,"G-OOOO-> (2) standard exception %s appeared after %d cycles.  <-OOOO-G",
                //                           ex.what(),i );
            }

            //----------------------------------
            catch(TjurekEventEndException & obj)
            {
                cout << "End of events in the file " << endl;
                info_to_cracow(" End of events in the file, saving ");
                PostLoop();
                info_to_cracow(" finished events");
                throw;
            }
            catch(Texception_input_file &obj)
            {
                if(obj.error_nr ==   myEOF)
                {
                    cout << "End of events in the file " << endl;
                    info_to_cracow(" End of events in the file, saving ");
                }

                PostLoop();
                info_to_cracow(" finished events");
                throw;
            }
            catch(...)
            {
                //cout << "Unknown exception - ignored (timeout ?, no events after "
                // << i << " cycles ?)" << endl;
                if(!flag_sorting_from_file)
                {
                    cout << "Timeout ?  no events comming from MBS now... (after "
                         << curr_ev_nr << " cycles )" << endl;
                    info_to_cracow("Timeout? No events from MBS now...  ", curr_ev_nr);
                    automatic.running(true);     // when MBS gives constant Timeout
                    // cracow would disable the icons of SPY
                    perhaps_delete_some_spectra();
                }
                else
                {
                    cout << "Unknown exception - after " << curr_ev_nr << " cycles ?)"
                         << " (can be also when timestamp is noticed as corrupted )" << endl;
                    //     cout << "Unknown exception - ignored (timeout ?, no events after "
                    //<< i << " cycles ?)" << endl;
                    //     cout << "End of file ?????? " << endl;
                    // throw;
                }
            }
            ////// end inner catch


        }// for
        // return 0; //times = 0;
        //         Message ( 0,"G-OOOO-> Analysis Implicit Loop has finished after %d cycles. <-OOOO-G",
        //                   i );
        PostLoop();
    } //  try


    catch(Texception_input_file & kkk)
    {
        if(kkk.error_nr == myEOF)
        {
            //info_to_cracow ( " saves spectra before finishing" );
            //PostLoop();  // << -was done above in (...) catch
        }
    }

    catch(Tcracow_exception & kkk)
    {
        if(kkk.message == "finish")
        {
            info_to_cracow(" saves spectra before finishing");
            PostLoop();  // << -was done above in (...) catch
        }
        else
        {
            cout << "unrecognized mesaage from Tcracow_exception " << endl;
            perhaps_conditions_report(true);    // parforce
            throw;
        }
    }
    catch(std::bad_alloc & ex)        // treat standard library exceptions
    {

        cout << "ERROR: Not enough memory to reserve the spectrum! " << endl;
        //         Message ( 0,"G-OOOO-> (1.9) bad_alloc exception %s appeared after %d cycles.  <-OOOO-G",
        //                   ex.what(), i );
    }
    catch(std::exception& ex)        // treat standard library exceptions
    {
        cout << "Standard  exception after " <<  curr_ev_nr << " cycles !!!  <-OOOO-G" << endl;
        //         Message ( 0,"G-OOOO-> (2) standard exception %s appeared after %d cycles.  <-OOOO-G",
        //                   ex.what(),i );
    }

    catch(...)
    {
        cout << "Unexpected exception after " <<  curr_ev_nr << " cycles !!!  <-OOOO-G"  << endl;
        //         Message ( 0,"G-OOOO-> !!! (1) Unexpected exception after %d cycles !!!  <-OOOO-G", i );
    }
    perhaps_conditions_report(true);    // parforce
    /////////// end outer catch block
    info_to_cracow("Finished after ", curr_ev_nr);
    return curr_ev_nr;
}
//***************************************************************************


#else
//***************************** when **********************************************

/** this is such a version which replaces the RunImplicitLoop,
  but is able to handle the pause and continue exceptions */
int TIFJAnalysis::run_jurek_ImplicitLoop(int times)
{

    const long int infinity = 999999999L;

    if(times == 0)
    {
        times = infinity; // was bug in go4
    }
    // automatic resources =====================================================
    class spy_works
    {

        string nazwa;
    public:
        spy_works()
        {
            nazwa = "commands/spy_works.command";
            ofstream plik(nazwa.c_str());
            plik << "running" << endl;
            plik.close();
        }
        void running(bool flag_running)
        {
            ofstream plik(nazwa.c_str());
            plik << (flag_running ? "running" : "paused")  << endl;
            plik.close();
        }

        ~spy_works()
        {
            remove
            (nazwa.c_str());
        }
    };

    spy_works automatic;


    //=========================================================================

    bool flag_pause = false;

    int curr_ev_nr = 0; // number of actually processed events
    try
    {
        user_batch();
        PreLoop();

        //         Message ( 0,"G-OOOO-> Analysis Implicit Loop for %d cycles is starting... <-OOOO-G",
        //                   times );

        last_ev_mbs_long_term_nr = 0;
        last_ev_analsyed_long_term_nr = 0;


        //times = 4;  // for testing
        for(curr_ev_nr = 0; curr_ev_nr < times  || (curr_ev_nr == infinity); ++curr_ev_nr)
        {
            if(curr_ev_nr == infinity) curr_ev_nr = 0 ;

            try
            {
                // here we could check if there are some spectra to delete
                perhaps_delete_some_spectra();
                check_for_commands(curr_ev_nr);
                save_just_observed(); // only the selected spectra just observed in cracow


                // ------------ in PAUSED state ------------------
                if(flag_pause)
                {
                    --curr_ev_nr;
                    // how often to look at the disk

                    static time_t last = time(0);
                    time_t now = time(0);
                    if(now - last > 3)
                    {
                        last = now;
                        // check on the disk for the command "continue"
                        string nazwa = "commands/spy_continue.command";
                        ifstream plik(nazwa.c_str());
                        if(plik)
                        {
                            info_to_cracow(" prepares to run again");
                            remove
                            (nazwa.c_str());
                            PreLoop();
                            flag_pause = false;
                            cout << "continue the analysis" << endl;
                            plik.close();
                            remove
                            (nazwa.c_str());    // second time, to be sure, because prelop takes time
                            automatic.running(true);

                            last_ev_mbs_long_term_nr =  0;
                            last_ev_analsyed_long_term_nr = curr_ev_nr;

                            info_to_cracow("Spy prepares to run again");

                        }
                        else
                        {
                            cout << "Spy paused by the cracow viewer request" << endl;
                            info_to_cracow(" is PAUSED  on ", curr_ev_nr);
                        }
                    }
                } //----------------------------- end if flag pause
                else
                {

                    /** Flag telling that now we want to dump information
                    about the current event */
                    //     if(verbose_mode_enabled)
                    //     {
                    //      if(i >= verbose_begins_with_event_nr
                    //        &&
                    //        i < (verbose_begins_with_event_nr + verbose_how_many_events)
                    //        )
                    //             {
                    //             flag_verbose_events = true;
                    //             // cout << "======= CyEvent nr " << i << " verbose listing =========" << endl;
                    //             // i is not an event nr. Events are those which pass to the calibration step.
                    //             }
                    //       else
                    //         { flag_verbose_events = false;}
                    //     }
                    perhaps_conditions_report();

                    MainCycle();

                    perhaps_info_of_events(curr_ev_nr);

                    //============== RATIO DISPLAY ===============
//                     static int print_ratios_every_n_events = 5000;
//                     static time_t previous_print_ratios_time = time(NULL);
//                     static int previous_print_event_nr = 0 ;

                    if(!(curr_ev_nr % print_ratios_every_n_events))
                    {
                        display_procent_ratios_and_speed(curr_ev_nr);

                    } // endif how often display rates


                    //=============================================

                    static time_t   time_last = time(0);    // so always at first save

                    time_t  time_now = time(0);

                    if(time_now - time_last > (autosave_period_in_minutes * 60))
                    {
                        info_to_cracow(" makes autosave");
                        PostLoop();
                        cout << "Autosave from  - finished (every " << autosave_period_in_minutes
                             << " minutes)" << endl;
                        time_last = time_now;
                        info_to_cracow(" finished autosave");
                    }

                    //save_just_observed(); // only the selected spectra just observed in cracow

                } // end else --- not paused

            } // end try
            //-------------------------

            //----------------------------
            catch(Tcracow_exception & kkk)
            {
                if(kkk.message == "pause")
                {
                    info_to_cracow("is PAUSED  on ", curr_ev_nr);
                    PostLoop();
                    flag_pause = true;
                    automatic.running(false);
                }
                else  if ( kkk.message == "pause_quick" )
                {
                    info_to_cracow ( "is PAUSED  on ", curr_ev_nr );
                    cout << "skipping spectra saving " << endl; // ----> no saving spectra in this option    PostLoop();
                    flag_pause = true;
                    automatic.running ( false );
                }
                else
                {
                    perhaps_conditions_report(true);    // parforce
                    throw;  // probably 'finish'
                }
            }
            //----------------------------
            //----------------------------
            catch(std::bad_alloc & ex)      // treat standard library exceptions
            {

                cout << "ERROR: Not enough memory to reserve the spectrum! " << endl;
                //                 Message ( 0,"G-OOOO-> (1.9) bad_alloc exception %s appeared after %d cycles.  <-OOOO-G",
                //                           ex.what(), i );
            }
            catch(std::exception& ex)        // treat standard library exceptions
            {

                //                 Message ( 0,"G-OOOO-> (2) standard exception %s appeared after %d cycles.  <-OOOO-G",
                //                           ex.what(),i );
            }

            //----------------------------------
            catch(TjurekEventEndException & obj)
            {
                cout << "End of events in the file " << endl;
                info_to_cracow(" End of events in the file, saving ");
                PostLoop();
                info_to_cracow(" finished events");
                throw;
            }
            catch(Texception_input_file &obj)
            {
                if(obj.error_nr ==   myEOF)
                {
                    cout << "End of events in the file " << endl;
                    info_to_cracow(" End of events in the file, saving ");
                }

                PostLoop();
                info_to_cracow(" finished events");
                throw;
            }
            catch(...)
            {
                //cout << "Unknown exception - ignored (timeout ?, no events after "
                // << i << " cycles ?)" << endl;
                if(!flag_sorting_from_file)
                {
                    cout << "Timeout ?  no events comming from MBS now... (after "
                         << curr_ev_nr << " cycles )" << endl;
                    info_to_cracow("Timeout? No events from MBS now...  ", curr_ev_nr);
                    automatic.running(true);     // when MBS gives constant Timeout
                    // cracow would disable the icons of SPY
                    perhaps_delete_some_spectra();
                }
                else
                {
                    cout << "Unknown exception - after " << curr_ev_nr << " cycles ?)"
                         << " (can be also when timestamp is noticed as corrupted )" << endl;
                    //     cout << "Unknown exception - ignored (timeout ?, no events after "
                    //<< i << " cycles ?)" << endl;
                    //     cout << "End of file ?????? " << endl;
                    // throw;
                }
            }
            ////// end inner catch


        }// for
        // return 0; //times = 0;
        //         Message ( 0,"G-OOOO-> Analysis Implicit Loop has finished after %d cycles. <-OOOO-G",
        //                   i );
        PostLoop();
    } //  try


    catch(Texception_input_file & kkk)
    {
        if(kkk.error_nr == myEOF)
        {
            //info_to_cracow ( " saves spectra before finishing" );
            //PostLoop();  // << -was done above in (...) catch
        }
    }

    catch(Tcracow_exception & kkk)
    {
        if(kkk.message == "finish")
        {
            info_to_cracow(" saves spectra before finishing");
            PostLoop();  // << -was done above in (...) catch
        }
        else
        {
            cout << "unrecognized mesaage from Tcracow_exception " << endl;
            perhaps_conditions_report(true);    // parforce
            throw;
        }
    }
    catch(std::bad_alloc & ex)        // treat standard library exceptions
    {

        cout << "ERROR: Not enough memory to reserve the spectrum! " << endl;
        //         Message ( 0,"G-OOOO-> (1.9) bad_alloc exception %s appeared after %d cycles.  <-OOOO-G",
        //                   ex.what(), i );
    }
    catch(std::exception& ex)        // treat standard library exceptions
    {
        cout << "Standard  exception after " <<  curr_ev_nr << " cycles !!!  <-OOOO-G" << endl;
        //         Message ( 0,"G-OOOO-> (2) standard exception %s appeared after %d cycles.  <-OOOO-G",
        //                   ex.what(),i );
    }

    catch(...)
    {
        cout << "Unexpected exception after " <<  curr_ev_nr << " cycles !!!  <-OOOO-G"  << endl;
        //         Message ( 0,"G-OOOO-> !!! (1) Unexpected exception after %d cycles !!!  <-OOOO-G", i );
    }
    perhaps_conditions_report(true);    // parforce
/////////// end outer catch block
    info_to_cracow("Finished after ", curr_ev_nr);
    return curr_ev_nr;
}
//***************************************************************************

#endif

//***************************************************************************
/**
 * @brief every  5000event os every 10 seceonds on the screen we dispaly
 * tthe stistics of events (how many percent of all incoming data is ananlysed
 * and  what is the speed (events per second)
 *
 * @param curr_ev_nr   number of currently analysed event
 * @return void
 **/
void TIFJAnalysis::display_procent_ratios_and_speed(const int curr_ev_nr)
{

    //============== RATIO DISPLAY ===============
    static int previously_displayed_ev_mbs_nr = 0;
    time_t now = time(NULL);

    if(previously_displayed_ev_mbs_nr != 0)      // to avoid first print
    {
        static time_t  speed_ratio__time_before = 0;
        cout << "\n--- Read " << curr_ev_nr << " events ";


        double recent_ratio =
            (100.0 * (curr_ev_nr - previous_print_event_nr))
            /
            ((*ptr_to_mbs_nr_of_the_current_event) - previously_displayed_ev_mbs_nr);


        double ratio_long_term =
            (100.0 * (curr_ev_nr - last_ev_analsyed_long_term_nr))
            /
            ((*ptr_to_mbs_nr_of_the_current_event) - last_ev_mbs_long_term_nr);

#if 0
        if(recent_ratio < 0)
        {
            cout << "NEGATIVE recent_ratio? "
                 << " curr_ev_nr = " << curr_ev_nr
                 << " previous_print_event_nr = " << previous_print_event_nr
                 << " *ptr_to_mbs_nr_of_the_current_event = " << (*ptr_to_mbs_nr_of_the_current_event)
                 << " previously_displayed_ev_mbs_nr = " << previously_displayed_ev_mbs_nr
                 << endl;

        }

        if(ratio_long_term < 0)
        {
            cout << "NEGATIVE ratio_long_term? "
                 << " curr_ev_nr = " << curr_ev_nr
                 << " last_ev_analsyed_long_term_nr = " << last_ev_analsyed_long_term_nr

                 <<  "(roznica = " << (curr_ev_nr - last_ev_analsyed_long_term_nr)
                 << "\nn *ptr_to_mbs_nr_of_the_current_event = " << (*ptr_to_mbs_nr_of_the_current_event)
                 << " last_ev_mbs_long_term_nr = " << last_ev_mbs_long_term_nr
                 <<  "  roznica = " << ((*ptr_to_mbs_nr_of_the_current_event) - last_ev_mbs_long_term_nr)
                 << "\n in result " << ratio_long_term
                 << endl;
            //exit(33);

        }
#endif
        // Long term statistics
        if(last_ev_mbs_long_term_nr != 0)
        {
            cout
                    << ", (ratio "
                    << ((ratio_long_term > 98)? 100.0 : ratio_long_term )                    
                    << "% of all coming)"
                    << "   [recently " 
		    << ((recent_ratio > 98)? 100.0 : recent_ratio )  
                    << "%]   ";
            //--- speed ---------------------
            static int previous_speed_event_nr = 0;
            int speed__time_diff = now - speed_ratio__time_before;
            int how_many_seconds_to_calculate_speed = 2;

            if(speed__time_diff >= how_many_seconds_to_calculate_speed)
            {
                double speed = (1.0 * (curr_ev_nr - previous_speed_event_nr)  / speed__time_diff);
                if(speed > 1)
                {
                    cout
                    //                    <<  "(curr_ev_nr - previous_print_event_nr) = " <<  (curr_ev_nr - previous_print_event_nr)
                    //          << " how_many_seconds_to_calculate_speed = " << how_many_seconds_to_calculate_speed
                    //           <<  " diff = " <<  speed_ratio__time_diff
                    //            << "\n(1.0 * (curr_ev_nr - previous_print_event_nr)  / diff)     "
                            << (1.0 * (curr_ev_nr - previous_speed_event_nr)  / speed__time_diff)
                            << " ev/s ";
                }
                speed_ratio__time_before = now;
                previous_speed_event_nr = curr_ev_nr;
            }
            else
            {
                //cout << " speed_ratio__time_diff " << speed__time_diff << endl;
            }

            int since_last_display = now - previous_print_ratios_time;
            if(since_last_display < 2)      // every n seconds
            {
                //print_ratios_every_n_events += 3000;
                print_ratios_every_n_events *= 2;
                //cout << "----------Mult Changed print_every_n_events, now is " << print_ratios_every_n_events << endl;
            }
            else if(since_last_display < 10)        // every n seconds
            {
                print_ratios_every_n_events += 3000;
                //                                  print_ratios_every_n_events *= 2;
                //                                  cout << "----------Added  print_every_n_events, now is " << print_ratios_every_n_events << endl;
            }

            previous_print_event_nr = curr_ev_nr;
            previous_print_ratios_time = now;

            if(ntuple_RAW_is_collected)
            {
                //cout << "\nNotice: The option to produce the n - tuple file(*_RAW_tree.root) is  ON.";
                // comented because the proper text is displayed form tree making function ;
            }
            if(ntuple_CAL_is_collected)
            {
                cout << "\nNotice: The option to produce the n - tuple file(*_CAL_tree.root) is  ON.";
            }

        }
        else
        {
            last_ev_mbs_long_term_nr =  *ptr_to_mbs_nr_of_the_current_event;
            last_ev_analsyed_long_term_nr = curr_ev_nr;
        }
        cout  << endl;
    } // endif how often display rates
    previously_displayed_ev_mbs_nr = *ptr_to_mbs_nr_of_the_current_event;
}
//***************************************************************************
/** Cracow viewer may send request to delete list of spectra */
void TIFJAnalysis::perhaps_delete_some_spectra()
{

    static int how_many_wrongly_finished_command_files;
    static time_t last = 0;
    time_t now = time(0);
    string full_name_of_spectrum;

    if(now - last > 2)    // every 3 seconds
    {
        last = now;
        // check on the disk for the command "continue"

        string nazwa = "commands/spy_spectra_for_zeroing.command";
        ifstream plik(nazwa.c_str());
        if(plik)
        {
            info_to_cracow(" is deleting spectra");
            string spec_name;
            while(plik)
            {
                plik >> spec_name;
                if(!plik)
                {
                    // this trick is made to compatibility with the old cracow programs
                    how_many_wrongly_finished_command_files++;
                    cout << "Error while reading the spec_name";
                    if(how_many_wrongly_finished_command_files < 20)
                    {
                        // most probably file is not finished yet - come later here ! (return without deleting the file)
                        return;
                    }
                    how_many_wrongly_finished_command_files = 0;
                    break;  // for old cracow - after 10 tries - give up !
                }// if plik
                cout << "Zeroing spectrum: " << spec_name << "\n" ;

                if(spec_name == "this_is_the_end_of_the_list_of_spectra_which_cracow_wants_to_zero")
                {
                    break;  // this was the last spectrum to delete
                }
                full_name_of_spectrum = spec_name;
                // remove extension
                string::size_type pos = spec_name.rfind(".mat");
                if(pos == string::npos)
                    pos = spec_name.rfind(".spc");
                if(pos != string::npos)
                    spec_name.erase(pos, 100);

                //cout << "Zeroing spectrum " << spec_name << endl;
                TH1 * wskaznik = GetHistogram(spec_name.c_str());

                if(wskaznik)
                {
                    wskaznik->Reset();
                    store_time_of_zeroing_spectrum(full_name_of_spectrum, now);
                }
                else
                {
                    cout << "!!!!!!!!!!!!!!  Spectrum " << spec_name
                         << " is not currently produced by spy !!!!!!!!!!!!!!!!!!!!"
                         << endl;
                }
                // " After Zeroing " << endl;
            } // while plik
            remove
            (nazwa.c_str());
            //info_to_cracow(" is saving new, deleted specta");
            //PostLoop();  // saving the new zeroed version
            plik.close();
            cout << endl;   // flushing
            save_just_observed(true);    // means NOW, do not wait for 10 s period
            save_times_of_zeroing_on_disk();
        } // if plik
    }
}
//**************************************************************************
/** If the cracow viewer is just observing some spectra, we will save them
more often */
void TIFJAnalysis::save_just_observed(bool unconditionally)
{
    static int matrix_save_multiplier;

    if(unconditionally)
        matrix_save_multiplier = 0;


    static time_t last = 0;
    time_t now = time(0);

    if(now - last > 10 // every 10 seconds
            ||                 // OR
            unconditionally)    // when we must save NOW (just after deleting)
    {
        last = now;
        // check on the disk for the command "continue"
        cout << "Saving spectra currently watched by cracow..." << flush;
        string nazwa = "commands/spectra_currently_watched.names";
        ifstream plik(nazwa.c_str());
        if(plik)
        {
            string spec_name;
            while(plik)
            {
                plik >> spec_name;
                if(!plik)
                    break;

//                 cout << "Saving spectrum " << spec_name << endl;

                // remove extension
                string::size_type pos = spec_name.rfind(".mat");
                if(pos == string::npos)
                {
                    pos = spec_name.rfind(".spc");
                }
                else
                {
                    // if it was matrix, check now - to not to save it too often
                    if((matrix_save_multiplier % 1))        // 1 times 'seldomer'
                    {
                        continue;
                    }

                }

                if(pos != string::npos)
                    spec_name.erase(pos, 100);


                //                 cout << "Saving spectrum " << spec_name << endl;
                // asking Rising, FRS and HEC to save those spectra

                // the trick below is to stop searching if it was found
                if(frs.save_selected_spectrum(spec_name))
                {}
                else if(hector.save_selected_spectrum(spec_name)) {}
                else if(save_analysis_local_spectrum(spec_name))
                {}
                else
                    cout << "Spectrum " << spec_name
                         << " not found, among spectra currently produced by the spy"
                         << endl;
            }

            // remove(nazwa);
            // PostLoop();  // saving the new zeroed version
            plik.close();
            cout << " done." << endl;

        }
        matrix_save_multiplier++;
    }
}
//***********************************************************************
/** If some spectra are defined here in the analysis class */
bool TIFJAnalysis::save_analysis_local_spectrum(string specname)
{
    for(unsigned i = 0; i < spectra_local.size(); i++)
    {
        if(specname == spectra_local[i]->give_name())
        {
            spectra_local[i]->save_to_disk();
            return true;
        }
    }

    for(unsigned i = 0; i < spectra_user.size(); i++)
    {
        if(specname == spectra_user[i]->give_name())
        {
            spectra_user[i]->save_to_disk();
            return true;
        }
    }
    return false;
}
//**************************************************************************
/** to checking if cracow gui is giving any pause/go command */
void TIFJAnalysis::check_for_commands(int nr_events)
{
    //  static time_t   time_last = time(0);

    time_t  time_now = time(0);

    // here we can try if the cracow viewer asked to finish the analysis
    // we look at this every 5 seconds

    int command_check_period_in_seconds = 2;
    static time_t   time_last_command_check = time(0);

    if(time_now - time_last_command_check > command_check_period_in_seconds)
    {
        time_last_command_check = time_now;
        //    cout << "Command check done " << command_check_period_in_seconds
        //        << " seconds)" << endl;

        //---------------
        //     info_to_cracow(" is running ", nr_events);


        //      ofstream plikinfo("./commands/spy_events.info");
        //      if(plikinfo &&  flag_spy_asked_to_quit == false )
        //      {
        //        plikinfo << "Spy is running, " << nr_events << " events "<< endl;
        //      }
        //      plikinfo.close();



       // bool flag_spy_asked_to_quit = 0;
        
        ifstream plik("./commands/spy_finish.command");
        if(plik)
        {

            info_to_cracow("Finished after ", nr_events);

            //flag_spy_asked_to_quit = true;

            cout << "Throwing the cracow exception" << endl;
            plik.close();
            remove
            ("./commands/spy_finish.command");

            Tcracow_exception kkk;
            kkk.message = "finish";
            throw kkk;
        }

        //---------------
        ifstream plik2("./commands/spy_pause.command");
        if(plik2)
        {
            string contents;
            plik2 >> contents;
// 			if ( plik2 )
// 				cout << "succes in reading " << endl;
// 			else
// 				cout << "Error during reading " << endl;

// 			cout << "Contents of the pause command is -->" << contents <<"<--" << endl;
            plik2.close();
            remove
            ( "./commands/spy_pause.command" );

            info_to_cracow ( "Spy: asked to pause after ", nr_events );

            cout << "Throwing the cracow pause exception" << endl;
            Tcracow_exception kkk;
            kkk.message = "pause";

            if ( contents == "quick" )
            {
// 				cout << "Discover the word 'quick' " << endl;
                kkk.message += string ( "_" + contents );
            }

            throw kkk;
        }
        // the exception continue is checks in the jurek_implit_loop()

    }
}
//*******************************************************************
/** sending an info message to the Cracow GUI */
void TIFJAnalysis::info_to_cracow(string s, int i)
{
    ofstream plikinfo("./commands/spy_events.info");
    if(plikinfo)
    {
        plikinfo << "SPY: " << s;
        if(i != -1)
        {
            plikinfo << i
                     << " events "
// 		     "(created "
//                      //  << " SUBevents read("
//                      << nr_events_analysed
//                      << " Events)"
                     ;
        }
        plikinfo << endl;
        plikinfo << time(0) << endl;
    }
    plikinfo.close();

}
//********************************************************************
/** No descriptions */
void TIFJAnalysis::perhaps_info_of_events(int nr_events)
{
    // static time_t   time_last = time(0);
    time_t  time_now = time(0);


    int command_check_period_in_seconds = 2;
    static time_t   time_last_command_check = time(0);
    if(time_now - time_last_command_check > command_check_period_in_seconds)
    {
        time_last_command_check = time_now;
        info_to_cracow(" is analysing, ",  nr_events);
    }
}

//**************************************************************
//**************************************************************
/** In preLoop moment */
void TIFJAnalysis::read_definitions_of_user_spectra()
{
    Tuser_condition::owner = this;

    //====================================================
    // BUT AT FIRST WE READ USER CONDITIONS DEFINITONS ---------
    // retrieving the names.
    vector<string> names =
        FH::find_files_in_directory("./conditions",
                                    ".cnd");

    // we always build new condition vector, so perhaps we should delete the conditions
    // from the old version
    for(unsigned i = 0; i < user_condition.size(); i++)
    {
        delete user_condition[i];
    }
    user_condition.clear();


#ifdef NIGDY

    for(unsigned nr = 0; nr < names.size(); nr++)
    {
        cout << "User defined condition definition file : " << names[nr]
             << endl;
        create_user_condition(names[nr]);
    }
#endif


    //========================================================
    // NOW WE REALLY READ USER SPECTRA DEFINIIONS ------------
    // retrieving the names.
    names =
        FH::find_files_in_directory("./definitions_user_spectra",
                                    ".user_definition");

    // loop which is looking into the directory for a specified definions *.

    for(unsigned nr = 0; nr < names.size(); nr++)
    {
        cout << "User defined spectrum definition file : " << names[nr] <<
             endl;
        create_user_spectrum(names[nr]);
    }
}
//**************************************************************
/** No descriptions */
void TIFJAnalysis::create_user_spectrum(string name_of_description)
{

    string pathed_name_of_description = "./definitions_user_spectra/" +
                                        name_of_description;

    //  cout << "In the string " << name
    //        << " lookin for the extension "
    //        << endl;

    string name_without_extension = name_of_description;

    string::size_type  extension_starts =
        name_of_description.find(".user_definition");

    if(extension_starts == string::npos)
    {
        cout << "In the string " << name_of_description
             << " the extension was not found"
             //<< " this should never happen "
             << endl;
        //return;
    }
    else
    {
        name_without_extension = name_of_description.erase(extension_starts,
                                 100);
    }

    user_spectrum_description  desc;
    desc.set_name(pathed_name_of_description);
    desc.read_from(pathed_name_of_description);

    //check if such a spectrum already exists in our vector
    bool known = false;
    int position =  0;
    Tuser_spectrum *spec = 0;

    for(unsigned i = 0; i < spectra_user.size(); i ++)
    {

        //    cout << "searching ih the table of specta: current item is "
        //          << spectra_user[i]->give_name() << endl;
        if(spectra_user[i]->give_name() == name_without_extension)
        {
            known = true;
            position = i;
            spec = spectra_user[i];
            break;
        }
    }



    bool should_be_created = false;

    if(!known)
    {
        // if not = create it and put into the vector
        should_be_created = true;
    }
    else     // if it is known
    {
        Tuser_spectrum *uspec = dynamic_cast<Tuser_spectrum *>
                                (spectra_user[position]);
        //  check dimmension, binning, beg, end (on x and y if necessery)

        if(desc.are_parameters_identical(uspec->give_description()) == false)
            // ONLY BINNING etc  was tested. (Not enable, incrementers!)
        {
            // if different:  delete the old spectrum from root,
            //    !!!! not important - the function create is doing this !!!

            // delete this entry from spectum list (user conditional spectra)
            spectra_user.erase(spectra_user.begin() + position);

            //and create the new one
            should_be_created = true;
        }
    }

    //---------------------------------------
    if(should_be_created)
    {
        cout << "user Spectrum had to be created " << endl;
        spec = new Tuser_spectrum();
        spec->read_in_parameters(name_without_extension);     // the path will be added automatically

        spec->create_the_spectrum();
        // during creation the spectrum registers itself
        // by calling  "remember_user_spectrum" from this class


        // put spectrum on the list user spectra
        spectra_user.push_back(spec);
    }
    else
    {
        // above spec was created with:  new Tspectrum_1D_conditional;
        cout << "Spectrum already existed" << endl;
        // somebody may change the enable/disable/incrementer list
        spec->read_in_parameters(name_without_extension);     // the path will be added automatically

    }


    //==============================================
    // attaching the conditon - we do it always, because
    // vector of conditions is evertime new
    //==============================================

    // here we should find the condition desired by this spectrum
    // and send its address


    string cn = (spec->give_description()).give_conditon_name();

    string::size_type pos = cn.rfind(".cnd");
    if(pos != string::npos)
        cn.erase(pos, 100);


    cout << "Trying to assign a condition named : " << cn << endl;
    if(cn == "No_condition")
    {
        spec->remember_address_of_condition(0);
    }
    else
    {
        unsigned i = 0;
        for(i = 0; i < user_condition.size(); i++)
        {
            if(user_condition[i]->desc.give_name() == cn)
            {
                spec->remember_address_of_condition(user_condition[i]);
                break;
            }
        }

        if(i >= user_condition.size())
        {

            // cout << "Condition with the name " << cn << " not found on the list"
            //  << " try to read it from the disk " << endl;

            // if not existing, try to create it
            spec->remember_address_of_condition(
                create_user_condition((spec->give_description()).give_conditon_name()));
        }

    } // end else no condition
}
//******************************************************************************
/** Conditions live independently. One condition can be shared by many spectra */
Tuser_condition*  TIFJAnalysis::create_user_condition(string name_of_description)
{

    string pathed_name_of_description = "./conditons/" + name_of_description;

    //  cout << "In the string " << name
    //        << " lookin for the extension "
    //        << endl;

    string name_without_extension = name_of_description;
    string::size_type  extension_starts = name_of_description.find(".cnd");
    if(extension_starts != string::npos)
    {
        name_without_extension =
            name_of_description.erase(extension_starts, 100);
    }


    // Check if it is not the snake situation

    static int level_of_nesting;
    static vector<string> nesting_trace;
    //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
    for(unsigned int i = 0; i < nesting_trace.size(); i++)
    {
        if(nesting_trace[i] == name_without_extension)
        {

            cout << "\nCondition nesting trace:\n";
            for(unsigned int k = 0; k < nesting_trace.size(); k++)
            {
                cout << "(" << k
                     << ") " << nesting_trace[k] << " -- > ";
            }
            cout << name_without_extension;

            cout << "\nERROR:Infinite nesting of the conditions at the level "
                 << level_of_nesting
                 << "\n - the condition called " << name_without_extension
                 << " was already on the level " << i
                 << "\n This \"Snake is eating its own tail\" " << endl;
            exit(1);

        }
    }

    level_of_nesting++;
    if(level_of_nesting > 1000)
    {
        cout << "Nesting the conitions reach the level " << level_of_nesting
             << "\n - it is unrealistic, most probably there is a situation "
             "\n 'Snake is eating its own tail' " << endl;
        exit(1);
    }


    nesting_trace.push_back(name_without_extension);

//  conditions are not registered in root, they do not have to have
//  any continuity after any PAUSE, so we can create them new everytime


    Tuser_condition *c = new Tuser_condition();
    c->read_in_parameters(name_without_extension);     // the path will be added automatically

// during creation the spectrum registers itself
// by calling  "remember_user_spectrum" from this class

// put spectrum on the list user spectra
    user_condition.push_back(c);

    level_of_nesting--;
    nesting_trace.pop_back();
    return c;

}
//************************************************************************

//***********************************************************************
/** No descriptions */
string TIFJAnalysis::give_current_filename()
{
    // this function should return of currently analysed disk file

    // string nazwa = "NotImplemented.Yet";
    return source_of_events->give_name_of_source() ;
}
//**********************************************************************
/** No descriptions */
Tuser_condition* TIFJAnalysis::give_ptr_to_cond(string cname)
{
    //cout << "Searching for cond node " << cname << endl;
    for(unsigned i = 0; i < user_condition.size(); i++)
    {
        //cout << "    " << user_condition[i]->give_name()<< endl;
        if(cname == user_condition[i]->give_name())
            return user_condition[i];
    }


    return    create_user_condition(cname);
}

/**********************************************************************/
// when par_force is true - we do not wait for 15 seconds period, but
// just do int immediately
void TIFJAnalysis::perhaps_conditions_report(bool par_force)
{
    time_t  time_now = time(0);
    const int period_in_seconds = 15;
    static time_t   time_last = time(0);
    if(par_force || (time_now - time_last > period_in_seconds))
    {
        time_last = time_now;


        struct tm * timeinfo;
        timeinfo = localtime(&time_now);
        ostringstream iii;
        iii
                << (par_force ?  " (par force) " : " (normal) ")
                << "Statistics \"Tested/True\" made at "
                <<  asctime(timeinfo)
                ;
        string information = iii.str();


        ofstream plik("./conditions/report.txt");

        plik << information << "\n";

        for(unsigned i = 0; i < user_condition.size(); i++)
        {
            plik << user_condition[i]->give_name()
                 << "\t"
                 << user_condition[i]->give_how_many_tested()
                 << "\t" << user_condition[i]->give_how_many_true()
                 << "\n";

        }
        plik.close();

    }
}
//************************************************************************************
/** use the named pointer to know the ntuple data sources */
void TIFJAnalysis::read_ntuple_options()
{
  ifstream plik("./options/collect_ntuple_file.option");
  if(!plik)
  {
    return; // no wish
  }
   
    // STEP 1NTUPLE =======================================
    // Perhaps the raw n-tuple is wanted
    
    try
    {
      ntuple_RAW_is_collected =
      (bool) FH::find_in_file(plik, "collect_raw_ntuple_file");
    }
    catch(...)
    {
      // this option is new, so it may be not always included
      ntuple_RAW_is_collected = false;
    }
    
    cout << __func__ << ":   ntuple_RAW_is_collected = " << ntuple_RAW_is_collected << endl;
    
    //GetAnalysisStep ( "Unpack" )->SetStoreEnabled ( ntuple_RAW_is_collected );
    
    // what to put into the ntuple
    
    // STEP 2 NTUPLE  ======================================
    // note, we do not need the variable for this option, it is enough if we do not
    // fill the vector 'ntuple_entry_vector'
    if((ntuple_CAL_is_collected =
      (bool) FH::find_in_file(plik, "collect_ntuple_file")) == false)
      {
        return;
      }
}
//************************************************************************************
  /** use the named pointer to know the ntuple data sources */
  void TIFJAnalysis::prepare_ntuple_addition()
  {
  cout << "TIFJAnalysis::prepare_ntuple_addition() " << endl;
    // This function is executed during PRELOOP time.
    // It reads from the disk the conditions when the event
    // will be good for the n-tuple
    // This is a little old fashioned. Perhaps we should use a user definied condition
    // to decide about it.



    // Just to remember what is this ntuple_entry_vector, see below...
    //
    //  struct ntuple_entry_data
    //  {
    //    string variable_name;             //  1.  Name of the variable
    //    double * variable_source_ptr;     //  2.  Address of the variable
    //    double * variable_ntuple_ptr;     //  3.  Address in the Tcalibrated event
    //  };

    ntuple_entry_vector.clear();
    step2_cond_ptr = 0;
    step2_cond_result_ptr = 0;


    // at first look it the user is going to create the ntuple now

    ifstream plik("./options/collect_ntuple_file.option");
    if(!plik)
    {
        return; // no wish
    }

    try
    {

        // STEP 1NTUPLE =======================================
        // Perhaps the raw n-tuple is wanted

        try
        {
            ntuple_RAW_is_collected =
                (bool) FH::find_in_file(plik, "collect_raw_ntuple_file");
        }
        catch(...)
        {
            // this option is new, so it may be not always included
            ntuple_RAW_is_collected = false;
        }

        cout << __func__ << " ntuple_RAW_is_collected = " << ntuple_RAW_is_collected << endl;
        
        //GetAnalysisStep ( "Unpack" )->SetStoreEnabled ( ntuple_RAW_is_collected );

        // what to put into the ntuple

        // STEP 2 NTUPLE  ======================================
        // note, we do not need the variable for this option, it is enough if we do not
        // fill the vector 'ntuple_entry_vector'
        if((ntuple_CAL_is_collected =
                    (bool) FH::find_in_file(plik, "collect_ntuple_file")) == false)
        {
            return;
        }


        FH::spot_in_file(plik, "condition_name");
        string cond_name ;
        plik >> cond_name ;

        prepare_condition_for_ntuple(cond_name);

        // Reading from the disk information about what must be ok to
        // have good event. This is
        // just this old fashioned way, instead just using the condition

        // Below we just read the settings of the ntuple dialog window in cracow
#ifdef NIGDY

        use_isotope_identifier_for_ntuple_events =
            (bool) FH::find_in_file(plik,
                                    "add_only_events_with_identified_isotopes");

        ntuple_mw_must_be_ok =
            (bool) FH::find_in_file(plik,
                                    "mw_must_be_present");
        ntuple_tof_must_be_ok =
            (bool) FH::find_in_file(plik,
                                    "tof_must_be_present");
        ntuple_sci_pos_must_be_ok =
            (bool) FH::find_in_file(plik,
                                    "sci_pos_must_be_present");
#ifdef CATE_PRESENT

        ntuple_cate_xy_must_be_ok =
            (bool) FH::find_in_file(plik,
                                    "cate_xy_must_be_present");
        ntuple_cate_energy_must_be_ok =
            (bool) FH::find_in_file(plik,
                                    "cate_energy_must_be_present");
#endif
#endif

        //        GetAnalysisStep ( "Calibrate" )->SetStoreEnabled ( true );



        // Now, the decisions what will be stored in the ntuple every event.
        // the list of this decisions will be looked every event during the analysis
        // so the process of storing data will be automated.

        // To register thie data on the list -
        // the user have to put the name (1) of the incrementer
        // and the address in the ntuple (2) wher this data should be stored
        // The third argument is a condition sine qua non for the whole event in the ntuple,
        // taken from the ntuple dialog window.
        // In the more modern version will not be important anymore, we replace it with the
        // normal user defined condition.


        // do not use so called "ALL..." incrementers here


        // --------------- If people wish  to have something in the  ntuple ----------------
#if CURRENT_EXPERIMENT_TYPE == G_FACTOR_OCTOBER_2005

        ntuple_entry_vector.push_back(
            ntuple_entry_data("xia_P_time_minus_Ge_time_OR_raw",
                              &fxCaliEvent->xia_P_time_minus_Ge_time_OR_raw,
                              false));
        ntuple_entry_vector.push_back(
            ntuple_entry_data("vxi_P_time_minus_Ge_time_OR_raw",
                              &fxCaliEvent->vxi_P_time_minus_Ge_time_OR_raw,
                              false));
#endif


#ifdef VXI_ELECTRONICS_FOR_GERMANIUMS_PRESENT

        ntuple_entry_vector.push_back(
            ntuple_entry_data("Rising_crystal_multiplicity",
                              &fxCaliEvent->Rising_crystal_multiplicity,
                              0));
#endif

#ifdef XIA_ELECTRONICS_FOR_GERMANIUMS_PRESENT

        ntuple_entry_vector.push_back(
            ntuple_entry_data("Rising_crystal_xia_multiplicity",
                              &fxCaliEvent->Rising_crystal_xia_multiplicity,
                              0));
#endif


        // -------------- end of  wishes ------------------------------



        // This is the list of wishes sent to me by Gavin Hammond


        /*--
          dE and E are made in the cate object (it is a singleton) and
          are not available as the separtate items on the incrementers list
          -------*/



#ifdef INFO_FOR_USERS

        How to put a new entry in the CAL tree ?
        It is easy if the desired value is already defined as an incrementer. In such a situation
        it is enough to make the following steps :

        Step 1.
        Make the desired entry in the cal Tree(TIFJCalibratedEvent.h)
for example :
            double xxx;
    (remember that the type is important. The raw values are usually "int")


        Step 2.
Here, below this info put the following comand:

        ntuple_entry_vector.push_back(ntuple_entry_data(
                                          "name_of_choosen_incrementer",   // <--- Type here the name of the desi
                                          &fxCaliEvent->xxx,                      // xxx is the name where the value should "go"
                                          false                                            // <-- leave it like this
                                      )) ;

#endif   //   end of  INFO


        // HERE IS THE PLACE TO PUT YOUR OWN ITEM TO THE "CALIBRTED" TREE






        // =========================================
        // Having the list fullfilled, now the program can look through this list and
        // find the addresses of such defined incrementers

        for(unsigned int i = 0; i < ntuple_entry_vector.size(); i++)
        {
            // searching in the table

            Tmap_of_named_pointers::iterator pos
                = named_pointer.find(ntuple_entry_vector[i].variable_name);
            if(pos != named_pointer.end())
            {
                // Key found
                // cout << "Found string " << (pos->first) << endl;
                // cout << pos->first << " odpowiada_adres "
                // << ((int) &(pos->second)) << endl;
                ntuple_entry_vector[i].variable_source_ptr  = const_cast<double*> (pos->second.double_ptr);
                if(ntuple_entry_vector[i].must_be_ok)
                {
                    ntuple_entry_vector[i]. validation_flag_ptr = pos->second.data_usable;
                }
                else
                {
                    ntuple_entry_vector[i]. validation_flag_ptr = 0;
                }
            }
            else
            {
                // Key NOT found
                cout << "In the definition of ntuple donors : "
                     << "  there is a name of the incrementer (variable):"
                     << ntuple_entry_vector[i].variable_name
                     << "\nwhich is not known to the spy.\n"
                     "Please correct this in the source file TIFJAnalysis, function:\n"
                     "     void TIFJAnalysis::prepare_ntuple_addition()"
                     //          "go to the cracow viewer now, open the definition of this condition\n"
                     //          "and choose one of the available incrementers"
                     << endl;
                exit(1);
            }

        }

        // the real adres is found


    }
    catch(Tfile_helper_exception & k)
    {
        cout << "Error in file ./options/collect_ntuple_file.option"
             << k.message << endl;
        exit(1);

    }

    // somewhere should be specified the name of the condition wchich will be tested
    // to say that the given event should (or not) go to the ntuple.


}
//**************************************************************************************
/** Real action of saving the data to the TRisnigCalibratedEvent
    this funtion is NOT called form the UserEventFunc() (it would be too late!!!!)
    it must be called from the calibration processor     */
//************************************************************************************
void TIFJAnalysis::put_data_to_ntuple()
{

//     bool is_good = true;
    //if(is_verbose_on())     cout << "Storing chosen data into the Ntuple calibrated event----------------" << endl;

#ifdef USER_INCREMENTERS_ENABLED
    // evaluate all the new user defined incrementers
    for(auto & ink : vector_of_user_incrementers) ink->reset_new_event();

    for(uint i = 0 ; i < vector_of_user_incrementers.size(); i++)
    {
        vector_of_user_incrementers[i]->evaluate_incrementer_for_current_event();
    }
#endif

    check_all_user_def_conditions(); // one of them may be used

#ifdef NOGO4

    // Below, in the conditional expression of this if statement should be call of the
    // condition by which the user decides if the current event goes to the ntuple or not.

    bool put_it = false;

    if(step2_cond_result_ptr == 0)
        put_it = true ; // no condition
    else
    {
        if(*step2_cond_result_ptr == true)
        {
            put_it = true ;
        }
        else
        {
            put_it = false ;
        }
    }


    if(put_it)      // if condition is OK
    {

        for(unsigned int i = 0; i < ntuple_entry_vector.size(); i++)
        {

            if(is_verbose_on())
                cout << "Putting " << ntuple_entry_vector[i]. variable_name << endl;

            if(ntuple_entry_vector[i]. validation_flag_ptr  != 0    // if sometimes can be not legal
                    &&
                    *ntuple_entry_vector[i]. validation_flag_ptr == false)    // if not legal now
            {
                if(is_verbose_on())
                    cout << "Invalidated event because  of : " << ntuple_entry_vector[i]. variable_name << endl;

                if(ntuple_entry_vector[i].must_be_ok)
                {
                    fxCaliEvent->SetValid(false);    //
                    is_good = false;
                    break;
                }
                continue; // bad, but we do not MUST have it ok,


            } // endif valid

            // here may be some problem, because not always this is double ?
            switch(ntuple_entry_vector[i].type_of_data)
            {

            case 1: // double  // this is normal double
                * ((double*) ntuple_entry_vector[i].variable_ntuple_ptr)   =
                    * ((double*) ntuple_entry_vector[i].variable_source_ptr);
                break;

            case 2:   // int
                * ((int*) ntuple_entry_vector[i].variable_ntuple_ptr)   =
                    * ((int*)(ntuple_entry_vector[i].variable_source_ptr));
                break;

            case 3: // this is normal bool
                * ((bool*) ntuple_entry_vector[i].variable_ntuple_ptr)   =
                    * ((bool*) ntuple_entry_vector[i].variable_source_ptr);
                break;

            default:
                cout << "Unrecognized type while TIFJAnalysis::put_data_to_ntuple()" << endl;
            } // end switch
        } // end for

        //fxCaliEvent->sci41LR_position = 1234;



#ifdef INFO_FOR_COPYING_RAW_TREE_DATA_INTO_CAL_TREE

        this is the place   where you can copy anything into the CAL Root Tree
        from RAW Root Tree

        To make below operation possible to compile, you must be sure
that:
        1. the such member data really exist in the RAW tree(surely yes)
        2. the mentioned member data exist in the CAL tree(you must make it!)
        (The type them is the same(so, they are both "double" or both of them are "int"))
        3. Put here below, the operation of copying
        --------
Example:
        --------
        Imagine that you would like to have in the CAL tree the information
        about   mw41_x_left(which exists in the RAW root tree)

        ad 1.
Look into  TIFJEvent.h and find this variable. Read that it has a type: "int"
        .

        ad 2.
        Go to TIFJCalibratedEvent.h and create the same entry

        int mw41_x_left;

        If you do
            not know where to place it precisely, do
                it at the end, just
                before the line
                int end_for_zeroing ;  //!  dummy member to recognize end for memset function


        ad 3.
        Now, below this info, place your copying instruction
        fxCaliEvent->mw41_x_left = fxEbEvent->mw41_x_left;


        You can also use the following macro
#define   COPYING_TREE_ONE_ENTRY(x) \
fxCaliEvent->(xxx) = fxEbEvent->(xxx);

    In this case below this info you just type the command

            COPYING_TREE_ONE_ENTRY(mw41_x_left);

        -------------- -
        ARRAYS
        -------------- -
        If you want to copy not the single entry, but an array
        you can use the memcpy command
        Lets assume, that we want copy from the RAW tree(TIFJEvent.h)
        the array
        int music_8_energy[8]


        1. Find it in the TIFJEvent.h file(just to know its type)

        2. Create exactly the same entry in the CAL tree(TIFJCalibratedEvent.h)

        int music_8_energy[8]

        If you do
            not know where to place it precisely, do
                it at the end, just
                before the line
                int end_for_zeroing ;  //!  dummy member to recognize end for memset function

        3. Now we need here, in this file, below this info the following copying
        insruction

        // example for to copy the whole array

        memcpy(fxCaliEvent->music_8_energy,   // <--- where to copy
               fxEbEvent->music_8_energy,     // from where
               sizeof(fxEbEvent->music_8_energy)      // how many bytes
              );

        The above instruction you can write easier using the macro(defined below)

        COPYING_TREE_ONE_ARRAY(music_8_energy);

        ......................HINT:
        ...........................

        If you put here below your commands they will work untill the next upgrade of spy. So
        the new version of spy TIFJAnalysis.cxx file will not contain it.
    In such a case you need to make it also in the new version.
            However, there is a good way to do
                it:
        type your commands in the separate file
        called(for example)
            my_instructions.inc
            and here below - just put the directive
#include "my_instructions.inc"
            When you get
            the newer version of spy, it is enoug if in the proper place
            of the file TIFJAnalysis.cxx(namely here below)
                you type this
                directive
#include "my_instructions.inc"
                .........................................................end of hint

#endif  // INFO_FOR_COPYING_RAW_TREE_DATA_INTO_CAL_TREE


                //-------------------------------------------------------------------------------------------------
                // usefull macro for a Single variable copy
#define   COPYING_TREE_ONE_ENTRY(xxx) \
fxCaliEvent->xxx = fxEbEvent->xxx;



                // usefull macro for an Array copy
#define   COPYING_TREE_ONE_ARRAY(xxx) \
    memcpy(fxCaliEvent->xxx, fxEbEvent->xxx, sizeof(fxEbEvent->xxx));
                //-------------------------------------------------------------------------------------------------


                //#########################################
                //   HERE IS THE PLACE TO PUT YOUR OWN WISHES (read infos above)

#ifdef NIGDY
                // Copying one particular simple entry ======================
                fxCaliEvent->mw41_x_left = fxEbEvent->mw41_x_left;
        // same using macro
        COPYING_TREE_ONE_ENTRY(mw41_x_left);

        // Copying an array ===========================
        memcpy(fxCaliEvent->music_8_energy,   // <--- where to copy
               fxEbEvent->music_8_energy,     // from where
               sizeof(fxEbEvent->music_8_energy)      // how many bytes
              );
        // same using another macro
        COPYING_TREE_ONE_ARRAY(music_8_energy);
        // End of examples, put your stuff  below
#endif




        // #########################################
    }
    else
    {
        // condition exists, but is False
        //cout << "This event will be unvalid in the ntuple, because of the condition "<< endl;
        //    // not
        //        fxCaliEvent->sci21LR_position = 123;
        //        fxCaliEvent->sci41LR_position = 123;
        //        fxCaliEvent->sci41UD_position = 123;
        //         fxCaliEvent->mw_41_x = -123;

        fxCaliEvent->SetValid(false);
        is_good = false;
    }

    //  if(  fxCaliEvent->IsValid()   &&
    //       (fxCaliEvent->cate_dE == 0  ||  fxCaliEvent->cate_E == 0)
    //        )
    //  {
    //     cout << "illegal dE E" << endl;;
    //
    //  }
    if(is_verbose_on())
    {
        cout << "this event is " << (is_good ? " good " : " BAD ")
             << " for the ntuple, status Valid =  " <<  fxCaliEvent->IsValid()  << endl;

    }

#endif



    // for test     fxCaliEvent->SetValid(true);
}
//******************************************************************************************************
/** No descriptions */
void TIFJAnalysis::incr_synchronisation_matices()
{}
//**********************************************************************************************
/** No descriptions */
void TIFJAnalysis::make_ratio_spectra()
{
    // return;

}
//*********************************************************************************************
/** No descriptions */
void TIFJAnalysis::prepare_ratio_vector()
{

    //  cout << "F. prepare_ratio_vector() " << endl;

    return;

#ifdef NIGDY //.....................................................................................

    struct single_ratio
    {
        string name;
        bool *test_it;
        int nr_success;
        int channel_to_increment;
        int spectrum_to_incremet;   // there may be more than one spectrum
    };

    vector<single_ratio> ratio_vector;
#endif      //...............................................................................................

    //  single_ratio r;
    //r.test_it = &(frs.sci21_ptr->position_ok);

    ratio_vector.clear();
    //                                                                        spectr nr 0, chan 1;

    int nr = 1;  // because 0 is 100%
    ratio_vector.push_back(single_ratio("sci21_position_when_ok", 0, nr++, "sci21_position_ok"));

    ratio_vector.push_back(single_ratio("mw41_x_when_ok", 0, nr++, "mw41_x_ok"));
    ratio_vector.push_back(single_ratio("mw41_y_when_ok", 0, nr++, "mw41_y_ok"));

    ratio_vector.push_back(single_ratio("mw42_x_when_ok", 0, nr++, "mw42_x_ok"));
    ratio_vector.push_back(single_ratio("mw42_y_when_ok", 0, nr++, "mw42_y_ok"));

    //  ratio_vector.push_back(single_ratio("music41_ok_for_ratio_purposes", 0, nr++, "music41_ok"));
    ratio_vector.push_back(single_ratio("sci41horiz_position_when_ok", 0, nr++, "sci41horiz_position_ok"));

    //  ratio_vector.push_back(single_ratio("target_scintillator_x_raw", 0, nr++, "target_scintillator_x_raw_fired"));
    //  ratio_vector.push_back(single_ratio("target_scintillator_y_raw", 0, nr++, "target_scintillator_y_raw_fired"));

#ifdef SCI41_VERTIC_PRESENT

    ratio_vector.push_back(single_ratio("sci41horiz_position_when_ok", 0, nr++, "sci41horiz_position_ok"));
    // ratio_vector.push_back(single_ratio("sci41horiz_position_when_ok", 0, nr++));

    ratio_vector.push_back(single_ratio("sci41vertic_position_when_ok", 0, nr++, "sci41vertic_position_when_ok"));
    // ratio_vector.push_back(single_ratio("sci41vertic_position_when_ok", 0, nr++));
#endif

#ifdef CATE_PRESENT

    ratio_vector.push_back(single_ratio("cate_flag_cate_xy_ok_and_only_one_hit_for_rate_purposes", 0, nr++,
                                        "cate_xy_ok_and_only_one_hit"));

    ratio_vector.push_back(single_ratio("cate_E_when_ok_and_only_one_hit", 0, nr++,
                                        "cate_E_ok_and_only_one_hit"));
#endif
    // still to make:
    // Ge - time (OR)
    // Hector time (OR)
    // Na time (OR)
    // DGF (OR of any  8 channels)

    // ------------------------------
    // another spectrum ?

    ratio_vector.push_back(single_ratio("sci21_left_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("sci21_right_fired", 0, nr++));

    ratio_vector.push_back(single_ratio("sci41horiz_left_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("sci41horiz_right_fired", 0, nr++));

#ifdef SCI41_VERTIC_PRESENT

    ratio_vector.push_back(single_ratio("sci41vertic_up_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("sci41vertic_down_fired", 0, nr++));
#endif

    ratio_vector.push_back(single_ratio("sci42_left_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("sci42_right_fired", 0, nr++));

    // mutliwires

    nr = 20;

    ratio_vector.push_back(single_ratio("mw21_left_raw_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("mw21_right_raw_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("mw21_up_raw_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("mw21_down_raw_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("mw21_anode_raw_fired", 0, nr++));
    nr = 30;
    ratio_vector.push_back(single_ratio("mw22_left_raw_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("mw22_right_raw_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("mw22_up_raw_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("mw22_down_raw_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("mw22_anode_raw_fired", 0, nr++));
    nr = 40;
    ratio_vector.push_back(single_ratio("mw41_left_raw_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("mw41_right_raw_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("mw41_up_raw_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("mw41_down_raw_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("mw41_anode_raw_fired", 0, nr++));
    nr = 50;

    ratio_vector.push_back(single_ratio("mw42_left_raw_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("mw42_right_raw_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("mw42_up_raw_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("mw42_down_raw_fired", 0, nr++));
    ratio_vector.push_back(single_ratio("mw42_anode_raw_fired", 0, nr++));



    nr = 100;
#ifdef CATE_PRESENT

    for(unsigned int i = 1; i < 10; i++)
    {
        ostringstream sss;
        sss << "cate_segm_" << i;

        nr = 100 + ((i + 1) * 10);
        string nnn = sss.str();
        ratio_vector.push_back(single_ratio(nnn + "_Si_energy_raw_when_fired", 0, nr++));
        ratio_vector.push_back(single_ratio(nnn + "_CsI_energy_raw_when_fired", 0, nr++));
        ratio_vector.push_back(single_ratio(nnn + "_Si_time_raw_when_fired", 0, nr++));
        ratio_vector.push_back(single_ratio(nnn + "_CsI_time_raw_when_fired", 0, nr++));
        ratio_vector.push_back(single_ratio(nnn + "_pin_a_raw_when_good", 0, nr++));
        ratio_vector.push_back(single_ratio(nnn + "_pin_b_raw_when_good", 0, nr++));
        ratio_vector.push_back(single_ratio(nnn + "_pin_c_raw_when_good", 0, nr++));
        ratio_vector.push_back(single_ratio(nnn + "_pin_d_raw_when_good", 0, nr++));

    }
#endif

    //----------------------
    // first in the name pointer map = is a string with the name
    // second is the name pointer
    for(unsigned int i  = 0; i < ratio_vector.size(); i++)
    {
        Tmap_of_named_pointers::iterator pos = named_pointer.find(ratio_vector[i].name);

        if(pos != named_pointer.end())
        {
            // Key found
            //        cout << "Found string " << (pos->first) << endl;
            //        cout << pos->first << " odpowiada_adres "
            //                << ((int) &(pos->second)) << endl;

            ratio_vector[i].test_it = pos->second.data_usable;
            //          ratio_vector[i].value_int = pos->second.data_usable;

        }
        else
        {
            // Key NOT found
            cout << "\nERROR: In the definition of RATIO statistics  "
                 <<    " there is a name of the incrementer (variable):\n"
                 << ratio_vector[i].name
                 << "\nwhich is not known to the spy.\n"
                 << endl;

            exit(1);
        }

    } // end for

}
//*********************************************************************80.0*********************
/** No descriptions */
int TIFJAnalysis::read_how_many_branches()
{

    string fname = "./mbs_settings/how_many_branches.dat";
    ifstream plik(fname.c_str());

    int how_many_branches;


    if(!plik)
    {
        cout << "file does not exist, so I assume default state" << endl;
        return 4;
    }

    try
    {
        how_many_branches =
            (int) FH::find_in_file(plik, "how_many_branches");
    }
    catch(Tno_keyword_exception &m)
    {
        cout << "error while reading the file " << fname << "\n\t"
             << m.message << endl;
        throw;
    }
    catch(Treading_value_exception &m)
    {
        cout << "error while reading the file " << fname << "\n\t"
             << m.message << endl;
        throw;
    }
    plik.close();
    return how_many_branches;

}

//*******************************************************************************************
/** For Franco Camera wish to make dump of selected events */
//void TIFJAnalysis::read_in_verbose_parameters()
//{
//
//  string nazwa ="commands/verbose_mode.command";
//  ifstream plik(nazwa.c_str() );
//  if(plik)
//  {
//    try
//    {
//      verbose_mode_enabled = (bool) FH::find_in_file(plik,"verbose_mode_enabled");
//
//      verbose_begins_with_event_nr  = (int) FH::find_in_file(plik,
//                            "verbose_begins_with_event_nr" );
//
//      verbose_how_many_events =  (int) FH::find_in_file(plik,
//                          "verbose_how_many_events" );
//      }
//      catch(Tfile_helper_exception &m)
//      {
//        cout << "Error while trying to read the file " << nazwa
//        << "\n Reason is: " << m.message << endl;
//        exit(1);
//      }
//
//  }
//  else {
//    verbose_begins_with_event_nr  = 0;
//       verbose_how_many_events = 0;
//  }
//
//}
//*****************************************************************************************
/** Autosave - all spectra may be saved every 20 minutes  */
void TIFJAnalysis::read_autosave_time()
{
    string fname = "./options/other_options.dat";
    ifstream plik(fname.c_str());

    if(!plik)
    {
        cout << "file does not exist, so I assume default state" << endl;
        autosave_period_in_minutes = 60;  // every hour
        return;
    }

    try
    {
        autosave_period_in_minutes =
            (int) FH::find_in_file(plik, "autosave_period_in_minutes");
    }
    catch(...)
    {
        autosave_period_in_minutes = 60;
    }
    plik.close();
    return;

}
//******************************************************************************
/** This function calculates the value of all the user defined conditions.
It may be used by the user defined spectra, but also as the decision
if the event should go to the ntuple. */
void TIFJAnalysis::check_all_user_def_conditions()
{

    for(unsigned i = 0; i < user_condition.size(); i ++)
        user_condition[i]->new_event_init();

    for(unsigned i = 0; i < user_condition.size(); i ++)
    {
//             cout << "============ Checking the value of the condition nr "
//             << i
//             << " called "
//             << user_condition[i]->desc.give_name()
//             << endl;

        user_condition[i]->calculate_value_of_condition();

//             cout << "Condition nr "
//             << i
//             << " called "
//             << user_condition[i]->give_name()
//             << " is  "
//             << (user_condition[i]->give_result() ? " TRUE " : " FALSE ")
//             << endl;




    }

}
//****************************************************************************
/** This function checks if the user wanted any condtion on the step2 ntuple
and sets a special pointer */
void TIFJAnalysis::prepare_condition_for_ntuple(string condition_name)
{

    //==============================================
    // attaching the conditon - we do it always in /*preloop*/, because
    // vector of conditions is evertime new
    //==============================================

    // here we should find the condition desired by this spectrum
    // and send its address

    string::size_type pos = condition_name.rfind(".cnd");     // removing the extension
    if(pos != string::npos)
        condition_name.erase(pos, 100);

    cout << "For step2 ntuple - Trying to assign a condition named : " << condition_name << endl;
    if(condition_name == "No_condition")
    {
        step2_cond_ptr = 0;  // null
    }
    else
    {
        unsigned i = 0;
        for(i = 0; i < user_condition.size(); i++)
        {
            if(user_condition[i]->desc.give_name() == condition_name)
            {
                step2_cond_ptr = user_condition[i];
                break;
            }
        }

        if(i >= user_condition.size())
        {

            // cout << "Condition with the name " << condition_name << " not found on the list"
            //  << " try to read it from the disk " << endl;

            // if not existing, try to create it
            step2_cond_ptr = create_user_condition(condition_name);
        }

    } // end else no condition

    if(step2_cond_ptr)
    {
        step2_cond_result_ptr = &step2_cond_ptr->result ;
    }
    else
    {
        step2_cond_result_ptr = 0 ;
    }
}
//*****************************************************************************
/** No descriptions */
void TIFJAnalysis::user_batch()
{
    string next_name = give_current_filename();

    // finding the extension
    string::size_type kropka  = next_name.rfind(".lmd");
    if(kropka != string::npos)
    {
        next_name.erase(kropka);
        //    cout << "Po wymazaniu extension " << next_name << endl;
    }
    // erasing the path
    string::size_type slash  = next_name.rfind("/");
    if(slash != string::npos)
    {
        next_name.erase(0, slash + 1);
    }
    next_name += ".bat" ;
    //  cout << "Name of the batch =>" << next_name << "<" << endl;
    //system("ls FeMo*");
    string komenda = ". ./" +  next_name;  // some system prefer command  'source' instead of '.'

    cout << "Trying to execute batch file =>" << komenda << "<" << endl;
    //int result =
    system(komenda.c_str());
    //result =     system("pwd");

    //  cout << "Result was = " << result << endl;
}
//***********************************************************************
void TIFJAnalysis::save_times_of_zeroing_on_disk()
{
    //return ; // because destroy does not work properly (see below)
    cout << "F. save_times_of_zeroing_on_disk() " << endl;

    ofstream plik("spectra/zeroing_times.bin", ios_base::binary);
    if(!plik)
    {
        cout << "Can't open file  for storing zeroing times " << endl;
        return;
    }

    string nazwa_wid;
    time_t when = 0 ;
    const unsigned int max_length_of_name = 200;

    map<string, time_t >::iterator it =
        map_of_zeroing.begin();

    for(; it != map_of_zeroing.end() ; it++)
    {

        nazwa_wid = it->first ;
        if(nazwa_wid.size() > max_length_of_name)
            continue;

        char tablica[max_length_of_name] = { 0 } ;  // name can be max for ex. 200 bytes long
        nazwa_wid.copy(tablica, nazwa_wid.size());
        plik.write((char*) tablica, sizeof(tablica));

        when = it->second ;
        plik.write((char*) &when, sizeof(when));
        if(!plik)
            break;
    }
}
//***********************************************************************
void TIFJAnalysis::restore_times_of_zeroing_from_disk()
{
    //     cout << "F. restore_times_of_zeroing_from_disk() " << ((int)time(0)) << endl;

    map_of_zeroing.clear();
    ifstream plik("spectra/zeroing_times.bin", ios::binary);
    if(!plik)
    {
        cout << "Can't open file  for restoring zeroing times " << endl;
        return;
    }

    string nazwa_wid;
    time_t when = 0 ;
    const int max_length_of_name = 200;

    while(plik)      // for(unsigned int i = 0 ;/* i < map_of_zeroing.size()*/ ; i++)
    {
        char tablica[max_length_of_name] = { 0 } ;  // name can be max for ex. 200 bytes long
        plik.read((char*) tablica, sizeof(tablica));
        nazwa_wid = tablica;

        plik.read((char*) &when, sizeof(when));
        if(!plik)
            break;
        map_of_zeroing[nazwa_wid] = when ;
    }
    //  cout << "Size of zeroing map is " << map_of_zeroing.size() << endl;

}

//**************************************************************************************************************************
void TIFJAnalysis::read_in__user_incrementers()
{

#ifdef USER_INCREMENTERS_ENABLED

    //#################################################
    cout << "Now, user defined incrementers..." << endl;
    vector_of_user_incrementers.clear();

#ifdef NIGDY

    vector_of_user_incrementers.push_back(
        new Tuser_incrementer("!suma",
                              "tpc41_energy_deposit",
                              Tuser_incrementer::plus,
                              "tpc42_energy_deposit")
    );


    vector_of_user_incrementers.push_back(
        new Tuser_incrementer("tof_21_22LL_cal_diff",
                              "tof_21_41_tof_LL_cal",
                              Tuser_incrementer::minus,
                              "tof_22_41_tof_LL_cal")
    );
    //
    vector_of_user_incrementers.push_back(
        new Tuser_incrementer("tof_21_22RR_cal_diff",
                              "tof_21_41_tof_RR_cal",
                              Tuser_incrementer::minus,
                              "tof_22_41_tof_RR_cal")
    );
    //
    vector_of_user_incrementers.push_back(
        new Tuser_incrementer("tof_21_22_calculated",
                              "tof_21_22LL_cal_diff",
                              Tuser_incrementer::plus,
                              "tof_21_22RR_cal_diff")
    );
#endif
    /***
      vector_of_user_incrementers.push_back(
        new Tuser_incrementer("sum_for_plamen_tof_21_41_LL_cal_minus_tof_22_41_LL_cal_"
                              "PLUS_tof_21_41_RR_cal_minus_tof_22_41_RR_cal",
                              "tof_21_41_LL_cal_minus_tof_22_41_LL_cal",
                              Tuser_incrementer::plus,
                              "tof_21_41_RR_cal_minus_tof_22_41_RR_cal")
      );
    ****/


    //========================================================
    // retrieving the names.

    try
    {
        cout << "Trying to open the user incrementes directory: ./incrementers_user_def " << endl;
        vector<string> names = FH::find_files_in_directory("./incrementers_user_def", ".incr");

        Tuser_incrementer::create_all_user_incrementers(names, vector_of_user_incrementers);
//         // loop which is looking into the directory for a specified definions *.
//         for(unsigned nr = 0; nr < names.size(); nr++)
//         {
//             cout << "User defined incrementer definition file :" << names[nr] << endl;
//             create_user_incrementer(names[nr]);
//         }


        // all of them are done now, where is the time when they go to the general list of incrementers?

    }
    catch(...)
    {
        cout << "Error while reading the users incrementers. " << endl;
        exit(21);
    }

#endif // #ifdef USER_INCREMENTERS_ENABLED

}
//*************************************************************************************************
//**************************************************************
/** No descriptions */
void TIFJAnalysis::create_user_incrementer(string name_of_description)
{
#ifdef USER_INCREMENTERS_ENABLED

    string pathed_name_of_description = "./incrementer_user_def/" + name_of_description;

    //  cout << "In the string " << name << " lookin for the extension " << endl;

    string name_without_extension = name_of_description;
    string::size_type  extension_starts = name_of_description.find(".incr");
    if(extension_starts != string::npos)
    {
        name_without_extension =
            name_of_description.erase(extension_starts, 100);
    }

    // Check if it is not the snake situation

    static int level_of_nesting;
    static vector<string> nesting_trace;
    //&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
    for(unsigned int i = 0; i < nesting_trace.size(); i++)
    {
        if(nesting_trace[i] == name_without_extension)
        {
            cout << "\nUser_incrementers   nesting trace: \n";
            for(unsigned int k = 0; k < nesting_trace.size(); k++)
            {
                cout << "(" << k << ") " << nesting_trace[k] << " --> ";
            }
            cout << name_without_extension;

            cout << "\nERROR: Infinite nesting of the incrementers at the level "
                 << level_of_nesting
                 << "\n - the incrementer called " << name_without_extension
                 << " was already on the level " << i
                 << "\n This \"Snake is eating its own tail\" " << endl;
            exit(1);
        }
    }

    if(++level_of_nesting > 1000)
    {
        cout << "Nesting the incrementers reach the level " << level_of_nesting
             << "\n - it is unrealistic, most probably there is a situation "
             "\n 'Snake is eating its own tail' " << endl;
        exit(1);
    }

    nesting_trace.push_back(name_without_extension);

    //  incrementers are not registered in root, they do not have to have
    //  any continuity after any PAUSE, so we can create them new everytime


    Tuser_incrementer *c = new Tuser_incrementer();
    c->read_in_parameters(name_without_extension);     // the path will be added automatically

    // put spectrum on the list
    vector_of_user_incrementers.push_back(c);

    level_of_nesting--;
    nesting_trace.pop_back();
    return /*c*/ ;
#endif // #ifdef USER_INCREMENTERS_ENABLED

}
//******************************************************************************
TjurekPolyCond* TIFJAnalysis::give_ptr_to_polygon(string name)
{
    for(unsigned int i = 0 ; i < list_of_polygons.size() ; i++)
    {
        if(list_of_polygons[i]->give_name() == name)
            return list_of_polygons[i];
    }
    return NULL;
}
//__________________________________________________________________________________________________________
void TIFJAnalysis::AddHistogram(TH1 * ptr_spec, const char*)
{
    flag_sorting_from_file = true;
    list_of_histograms.push_back(ptr_spec);
}
//__________________________________________________________________________________________________________
// Getting the events  from the file
//__________________________________________________________________________________________________________
const_daq_word_t*  TGo4MbsFileParameter::give_next_event(int * how_many_words)    // virtual
{
    //cout << "F. TGo4MbsFileParameter::give_next_event " << endl;

    // version for MBS files
top:

    int result = mbs.get_next_event();
    ++nr_of_current_event;

    // if NOMORE
    if(result == GETEVT__NOMORE)      // || block_number > when_to_stop)
    {
        cout << " End of event file " << current_file << " while reading the event nr "
             << nr_of_current_event
             << endl;
        //       cout << "1 Read byte nr " << gdzie
        //       << " what is " << (100.0 *gdzie)/file_size  << "%  of " << file_size<< endl;
        if(open_next_file_from_the_list())
        {
            goto top;
        }
        else
        {
            cout << "TGo4MbsFileParameter::give_next_event   --->  Error while reading event !!!!!!" << endl;
            exit(3);
        }
    }
    // if this is another error than EOF
    else if(!file)
    {
        cout << "TGo4MbsFileParameter::give_next_event --->  Error while reading event !" << endl;
        exit(3);
    }


    return nullptr;   // fake
}
//***************************************************************************
//***************************************************************************
/*!
    \fn TGo4MbsFileParameter::open_file(string name)
 */
bool TGo4MbsFileParameter::open_file(string filename)
{

//     cout << "\nTGo4MbsFileParameter::open_file  [" << filename <<"]"<< endl;

    if(filename[0] == '@')      // if this is a list of files to analyse
    {
        flag_list = true;
        nr_of_file_already_analysed = 0 ;
        cout << "This is a LIST of files. " << endl;
        string name_without_at = filename.substr(1);
        ifstream plik(name_without_at.c_str());
        if(!plik)
        {
            cout << "Can't open the file " << name_without_at << " with the list of files  --> called " << endl;
						system("ls");
            return false;
        }

        filename_with_list_of_lmds_list = filename.substr(1);
        // Reading the contents of the file with the list and creating a vector with these names.
        string single_name;
        for(int i = 0 ; plik.good() ; i++)
        {
            plik >> single_name ;
            if(!plik) break;
            cout << (i + 1) << ".  file on the list is: " << single_name << endl;


            list_of_names.push_back(single_name);
        }
        filename = list_of_names[0];
    }
    else     // if this is a name of the single file to analyse
    {
        flag_list = false;
        list_of_names.push_back(filename);     // put this name on the list
    }


#ifdef MBS_DATAFILE
    current_file = filename ;
    if(mbs.open( MBS_File, filename ) != GETEVT__SUCCESS) {
        cout << "Error while opening the file " << endl;
        exit(1);
    }

    if(mbs.get_next_event() != GETEVT__SUCCESS) {
        cout << "Error while reading mbs event" << endl;
        exit(1);
    }

#else // normal prisma file
    //  plik.close();
    file.open(filename.c_str(), ios::binary);
    if(!file)
    {
        cerr << "Can't open file " << filename << endl;
        return false;
    }

//     cout << "\nTGo4MbsFileParameter::open_file(string name)      File   " << filename  << "    successfully open for analysis "<< endl;
    current_file = filename;

    file.seekg(0, ios::end);
    file_size = file.tellg();
    file.seekg(0, ios::beg);
    long pocz = file.tellg();
    file_size -= pocz;

#endif

//     cout << " TGo4MbsFileParameter::open_file    ===>   (size = " << file_size << "),  nr_of_file_already_analysed = "
//          << nr_of_file_already_analysed << endl ;

//     cout << "1 list_of_names.size() = " << list_of_names.size() << endl;
//     cout <<"1 buffor to read in is 0x" << hex << ( long ) data << dec<< endl;


    if(sizeof(daq_word_t)  != 4)
    {
        cerr << "ERROR: on this computer the size of event buffer word is not 4. , so\n "
             "The programmer should change the definition of typedef const_daq_word_t" << endl;
        exit(__LINE__);
    }
    return true;
}
//***************************************************************
bool TGo4MbsFileParameter::open_next_file_from_the_list()
{
    //cout << "TGo4MbsFileParameter::open_next_file_from_the_list() " << endl;
    static vector<string> skipped_files;

    
top:
    if(!flag_list)
    {
        cout << "The whole list file is analysed after event number " << mbs.give_event_nr() << endl;


        Texception_input_file x(myEOF);
        throw x;
    }
    nr_of_file_already_analysed++;
    if(nr_of_file_already_analysed >= list_of_names.size())
    {

        if(skipped_files.size())
        {
          cout << "\n\nNOTE: The List of  *lmd files has been analysed (after " << mbs.give_event_nr()  << " events)\n" 
          << string (75, '!')
          << "\nHowever, the files  listed below were impossilble to open (so: skipped )   " << endl;
          for(unsigned int i = 0 ; i < skipped_files.size() ;++i)
          {
            cout << (i +1) << ")    "<< skipped_files[i] << endl;
          }
          cout << string (75, '!') << "\n" << endl;
        }
        else         cout << "ALL Listed files are already analysed after (after " << mbs.give_event_nr()  << " events" << endl;
        
        Texception_input_file x(myEOF);
        throw x;
    }

//     cout << "222 list_of_names.size()" << list_of_names.size() << endl;
    if(nr_of_file_already_analysed >= list_of_names.size())
    {
        cout << "ALArm - bigger than the vector?" << endl;
    }

    cout
            << "nr_of_file_already_analysed = "  << nr_of_file_already_analysed
            << endl;


    cout
            << "\n\nCurrent file to analysis  has a name "
            << list_of_names.at(nr_of_file_already_analysed)
            << endl;


#ifdef MBS_DATAFILE
    mbs.close();
    //cout << "$33 Finished with File nr " << nr_of_file_already_analysed << endl;
// repair the error state

    // repair the stream
    // ??? file.clear(file.rdstate() & ~(ios::eofbit | ios::failbit));



    // opening the data file to analyse
    int result = mbs.open( MBS_File,  list_of_names[nr_of_file_already_analysed].c_str());
if(result == 4)
{
   cout << "NO file here " << endl;
   skipped_files.push_back(list_of_names[nr_of_file_already_analysed]);
   goto top;
}

    else if(result != 0)
    {
        cout << "error while opening a new mbs file called "
             << list_of_names[nr_of_file_already_analysed] << endl;
             Texception_input_file x(myFAIL);
             throw x;
    }
    
    current_file = list_of_names[nr_of_file_already_analysed];
    // if successful,
    return true;
#else

    file.close();
    cout << "$11 File nr " << nr_of_file_already_analysed << endl;
    // repair the error state

    // repair the stream
    file.clear(file.rdstate() & ~(ios::eofbit | ios::failbit));


    // opening the data file to analyse
    file.open(list_of_names[nr_of_file_already_analysed].c_str(),  ios::binary);
    if(!file)
    {
        cerr << "Can't open file with events " << list_of_names[nr_of_file_already_analysed] << endl;
        Texception_input_file x(myFAIL);
        throw x;
    }
    cout << "File " << list_of_names[nr_of_file_already_analysed]
         << " successfully open for analysis " << endl;

    file.seekg(0, ios::end);
    file_size = file.tellg();
    file.seekg(0, ios::beg);
    long pocz = file.tellg();
    file_size -= pocz;

    current_file = list_of_names[nr_of_file_already_analysed];
    // read_in_next_block();  // skiping info block? - not needed for Exotic
    //    read_in_next_block();    // reading the real data block <---- no in case of exotic, the proper function will ask for event in proper time,

    // skipping file header 40 bytes
    // skipping file header 40 bytes
    if(data_buffer.size() < 40) data_buffer.resize(40);

    file.read((char*)(&data_buffer[0]), 10 * sizeof(long));
    if(!file)
    {
        cout << "2. Error while reading (skipping) file header of the data 40 bytes" << endl;
    }
    // if successful,
    return true;
#endif
}
//*************************************************************************



