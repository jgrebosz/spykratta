//---------------------------------------------------------------
//        Go4 Framework release package V.1.0000
//                      24-May-2002
//---------------------------------------------------------------
//   The GSI Online Offline Object Oriented (Go4) Project
//   Experiment Data Processing at DVEE department, GSI
//---------------------------------------------------------------
//
//Copyright (C) 2000- Gesellschaft f. Schwerionenforschung, GSI
//                    Planckstr. 1, 64291 Darmstadt, Germany
//Contact:            http://go4.gsi.de
//----------------------------------------------------------------
//This software can be used under the license agreements as stated
//in Go4License.txt file which is part of the distribution.
//----------------------------------------------------------------
/* Generated by Together */

#ifndef TEBEVENTPROCESSOR_H
#define TEBEVENTPROCESSOR_H
//#include "Go4Event/TGo4EventElement.h"
#include <cstring>
#include <cstdlib>
#include <cstdint>

#include "tjurekabstracteventprocessor.h"

#include "TjurekMbsSubEvent.h"
#include "TjurekMbsEvent.h"

class TIFJEvent;
class TGo4SimpleEvent;
class TIFJEventProcessor;
// class TGo4MbsEvent ;
// class TGo4MbsSubEvent;

#include <vector>
#include <list>
#include <queue>
#include <iterator>
#include <string>

#include <iostream>

#include "Tlookup_table.h"
#include "Tlookup_table_miniball.h"
#include "Tlookup_table_doublets.h"
#include "Tlookup_table_triple_universal.h"
#include "Tlookup_table_kratta.h"

#include "Tfile_helper.h"
#include "experiment_def.h"

/**
 * Event processor to build EBEvents from the raw MbsEvents.
 */

/**
 * ----- with many changes by Jurek Grebosz and Alexander Buerger ------
 *
 */


class spectrum_1D ;
class spectrum_2D ;


//typedef int old_long;

typedef uint32_t daq_word_t;
typedef const uint32_t const_daq_word_t;


#if 1
// here we may see so called Visiting card
struct Tvisitcard
{
    char type[8];           // type of VME board
    char name[8];           // specific name of the board
    uint32_t hwaddr;        // VME address of the board
    uint32_t size;          // size of the data block, starting from type
    uint32_t data;          // Should be always last!
};

#endif

/////////////////////////////////////////////////////////////////////////////////
class vme_775_header_word
{
public:
    //unsigned int         : 8 ;  // <--- this was in the printed doc, but is not true
unsigned int cnt     :
    14; // 6+8 ;
unsigned int         :
    2 ;
unsigned int crate   :
    8 ;
unsigned int code    :
    3 ;
unsigned int geo     :
    5 ;
};
////////////////////////////////////////////
class vme_775_data_word
{
public:
unsigned int data    :
    12 ;
unsigned int ov      :
    1 ;
unsigned int un      :
    1 ;
unsigned int         :
    2 ;
unsigned int channel :
    6 ;
unsigned int         :
    2 ;
unsigned int code    :
    3 ;
unsigned int geo     :
    5 ;
};
////////////////////////////////////////////
class vme_775_eob_word
{
public:
unsigned int ev_counter   :
    24 ;
unsigned int code    :
    3 ;
unsigned int geo     :
    5 ;
};
////////////////////////////////////////////
union vme_775_word
{
    daq_word_t              raw_word ;
    vme_775_header_word      header_word ;
    vme_775_data_word        data_word ;
    vme_775_eob_word         end_of_block_word ;
};
//@@@@@@
/////////////////////////////////////////////////////////////////////////////////
class vme_785_header_word
{
public:
    //unsigned int         : 8 ;  // <--- this was in the printed doc, but is not true
unsigned int cnt     :
    14; // 6+8 ;
unsigned int         :
    2 ;
unsigned int crate   :
    8 ;
unsigned int code    :
    3 ;
unsigned int geo     :
    5 ;
};
////////////////////////////////////////////
class vme_785_data_word
{
public:
unsigned int data    :
    12 ;
unsigned int ov      :
    1 ;
unsigned int un      :
    1 ;
unsigned int         :
    2 ;
unsigned int channel :
    5 ;
unsigned int         :
    3 ;
unsigned int code    :
    3 ;
unsigned int geo     :
    5 ;
};
////////////////////////////////////////////
class vme_785_eob_word
{
public:
unsigned int ev_counter   :
    24 ;
unsigned int code    :
    3 ;
unsigned int geo     :
    5 ;
};
////////////////////////////////////////////
union vme_785_word
{
    daq_word_t        raw_word ;
    vme_785_header_word      header_word ;
    vme_785_data_word        data_word ;
    vme_785_eob_word         end_of_block_word ;
};

/////////////////////////////////////////////////////////////////////////////////
class trigger_14_header_word
{
public:
unsigned int cnt     :
    6 ;
unsigned int         :
    2 ;
unsigned int full_scale_range :
    8 ;
unsigned int forCATE :
    8 ;
unsigned int code    :
    3 ;
unsigned int geo     :
    5 ;
};
////////////////////////////////////////////
class trigger_14_data_word
{
public:
unsigned int threshold    :
    8 ;
unsigned int kill         :
    1 ;
unsigned int        :
    7 ;
unsigned int channel :
    6 ;
unsigned int         :
    2 ;
unsigned int code    :
    3 ;
unsigned int geo     :
    5 ;
};
////////////////////////////////////////////
class trigger_14_eob_word
{
public:
unsigned int status_register   :
    16 ;
unsigned int         :
    8 ;
unsigned int code    :
    3 ;
unsigned int geo     :
    5 ;
};
////////////////////////////////////////////

union trigger_14_word
{
    daq_word_t        raw_word ;
    trigger_14_header_word      header_word ;
    trigger_14_data_word        data_word ;
    trigger_14_eob_word         end_of_block_word ;
};

//============================================
/////////////////////////////////////////
class vme767_header_word
{
public:
unsigned int evnet_nr:
    12;
unsigned int         :
    9;
    //unsigned int header  : 1;
unsigned int code    :
    2;
unsigned int         :
    4;
unsigned int geo     :
    5 ;
};
/////////////////////////////////////////
class vme767_data_word
{
public:
unsigned int time_data  :
    20;
unsigned int edge       :
    1;
    // unsigned int eob        : 1;
    // unsigned int header     : 1;
unsigned int code    :
    2;
unsigned int start      :
    1;
unsigned int channel    :
    7;
};
/////////////////////////////////////////
class vme767_eob_word
{
public:
unsigned int ev_counter   :
    16 ;
unsigned int  :
    5 ;
    // unsigned int eob        : 1;
    // unsigned int header     : 1;
unsigned int code    :
    2;
unsigned int  :
    1 ;
unsigned int status :
    3 ;
unsigned int geo     :
    5 ;
};
/////////////////////////////////////////
/////////////////////////////////////////
union vme767_word
{
    daq_word_t           raw_word ;
    vme767_header_word      header_word ;
    vme767_data_word        data_word ;
    vme767_eob_word         end_of_block_word ;
};

union general_vme_word
{
    vme767_word word767;
    vme_775_word    word775;
};


class Texception_timestamp_corrupted
{};

//----------------------------------------------------------------------------


/////////////////////////////////////////////////////////////
// this class below is a relict and now it helps to make kind
// of statistics and prints
/////////////////////////////////////////////////////////////
class time_stamp_value
{

#ifndef  __CINT__
    // warning this trick with the conditional compilation had to be
    // done, because ROOT does not support "long long"
    // so during "making directory" time, this definition below
    // will be masked

    long long full ;

#endif
    bool flag_1Hz_trigger;


public:
    time_stamp_value(daq_word_t low = 0,
                     daq_word_t middle = 0,
                     daq_word_t high = 0,
                     bool one_Hz = false)
        : flag_1Hz_trigger(one_Hz)
    {
        if(!time_stamp_ok(low, middle, high))
        {
            //      cout << "Throwing time stamp corrupted exception because "
            //            << " low = 0x" << hex << low
            //            << ", middle = 0x" << hex << middle
            //            << ", high = 0x" << hex << high
            //            << dec << endl;

            Texception_timestamp_corrupted obj ;
            throw obj;
        }

        full = ((((unsigned long long)high & 0xffff) << 32)
                | ((middle & 0xffff) << 16)
                | (low & 0xffff));

    }

    bool has_1Hz_flag()
    {
        return flag_1Hz_trigger ;
    }


    friend ostream& operator<<(ostream & s , const time_stamp_value &ts)
    {
        s
        // << ts.high() << ":"   // to make listing narrower we skip the highest part
        // << ((ts.middle() << 16) | ts.low()) ;  // this is slower
        // << ts.two_lower                        // instead i made this, faster
        // << (ts.full & 0x000000ffffff) ;
                << (ts.full) ;
        return s ;
    }

    //----------------------------------------------------------
    long long operator-(time_stamp_value const & ts)
    {
        return full - ts.full ;
    }

    //-----------------------------------------------------------
    //function to check if the time stamps had codes for
    // low middle and high part (0f7, 1f7, 2f7)

    bool time_stamp_ok(unsigned low, unsigned middle, unsigned high)
    {
        return(
                  (
                      (low    & 0xffff0000) == 0x00f70000)
                  &&
                  ((middle & 0xffff0000) == 0x01f70000)
                  &&
                  ((high   & 0xffff0000) == 0x02f70000)
              ) ;
    }

    long long give_ts() const
    {
        return full ;
    }
    //----------------------------

};
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////------------------------
class timestamped_subevent
{
private:


#ifndef  __CINT__
    // warning this trick with the conditional compilation had to be
    // done, because ROOT does not support "long long"
    // so during "making directory" time, this definition below
    // will be masked

    long long time_stamp_value ;

#endif


    vector<daq_word_t> vec ;            // for data words
    //int nr ;                               // nr, only for debugging

public:

    timestamped_subevent(daq_word_t low, daq_word_t middle, daq_word_t high,
                         daq_word_t *address, int length_long_words
                         //, int n
                        ): vec(address, address + length_long_words)
    {
        //nr = n ;
        if(!time_stamp_identifiers_ok(low, middle, high))
        {
            //        cout << "timestamp corrupted " << endl ;
            Texception_timestamp_corrupted  obj;
            throw obj  ;
        }

        // they have to be masked below
        time_stamp_value =
            (((unsigned long long)high & 0xffff) << 32)
            | ((middle & 0xffff) << 16)
            | (low    & 0xffff);
    }

    //=====================================================
    // another constructor for situation when the subevent consists of two parts
    //=====================================================
    timestamped_subevent(daq_word_t low, daq_word_t middle, daq_word_t high,
                         daq_word_t *addressA, int length_long_wordsA,
                         daq_word_t *addressB, int length_long_wordsB
                        ): vec(addressA, addressA + length_long_wordsA)
    {
        // first part was added in the initilisation list
        // second pard is added now
        vec.resize(length_long_wordsA + length_long_wordsB);
        for(int i = 0 ; i < length_long_wordsB ; i++)
        {
            vec[length_long_wordsA + i] = addressB[i];
        }


        if(!time_stamp_identifiers_ok(low, middle, high))
        {
            //        cout << "timestamp corrupted " << endl ;
            Texception_timestamp_corrupted  obj;
            throw obj  ;
        }

        // they have to be masked below
        time_stamp_value =
            (((unsigned long long)high & 0xffff) << 32)
            | ((middle & 0xffff) << 16)
            | (low    & 0xffff);
    }

    //--------------------------------

    // function to check if the time stamps had codes for
    // low middle and high part (0f7, 1f7, 2f7)

    static bool time_stamp_identifiers_ok(daq_word_t low, daq_word_t middle, daq_word_t high)
    {
        return
            (
                ((low & 0xffff0000) == 0x00f70000)
                &&
                ((middle & 0xffff0000) == 0x01f70000)
                &&
                ((high & 0xffff0000) == 0x02f70000)
            ) ;
    }
    long long give_ts() const
    {
        return time_stamp_value ;
    }

    //-------------------------------
    long long operator-(timestamped_subevent const & tb) const
    {
        return time_stamp_value - tb.time_stamp_value ;
    }
    //--------------------------------
    daq_word_t give_word(unsigned int i) const
    {
        if(i < vec.size())
        {
            return vec[i] ;
        }
        else
        {
            return 0 ;
        }
    }

    //---------------------------------
    int length() const
    {
        return vec.size();
    }

    //--------------------------------
    friend ostream& operator<<(ostream & s , const timestamped_subevent &tb)
    {
        s
                << "["
                //<< tb.nr
                << "], "
                << tb.time_stamp_value
                ;

        return s ;
    }
};

//////////////////////////////////////////////////////////////////////
//* a class which makes kind of lookup table for FRS signals
//////////////////////////////////////////////////////////////////////
class frs_signal
{
    string description;
    int crate;  // from which VME crate & slot it comes
    int slot;
    int *where_goes;  // where to put it


public:
    // constructor may be automatically generated
    frs_signal(): description("xxx"), where_goes(0) {} ;
    //***********************************------
    frs_signal(ifstream & plik, string des, int *wh)
    {

        // read such a string from the disc
        crate = (int) FH::find_in_file(plik, des);
        if(crate > 21 || crate < 0)
        {
            cout << "Lookup table for FRS, item called " << des
                 << "has crate nr " << crate << " which is > 21" << endl ;
            exit(-1);
        }

        plik >> zjedz >> slot ;
        // check results
        if(slot < 0 || slot > 31)
        {
            cout << "Lookup table for FRS, item called " << description
                 << "has slot nr " << slot << " which is > 31" << endl ;
            exit(-1);
        }
        // if success...
        description = des;
        where_goes = wh;
    }
    // ---------------------------------------

    //------------------------------------
    void put_this_item(daq_word_t  selected_vme[22][32])
    {
        *where_goes = selected_vme[crate][slot];
        //    cout << "Putting signal from crate " << crate << ", slot " << slot
        //           << ", into =" << description << "=" << endl;
    }

};
//////////////////////////////////////////////////////////////////////

enum what_to_do { take_another_subevent,       event_ready,      try_another }; // for result of matching funct.

class TGo4EventSourceParameter;
//////////////////////////////////////////////////////////////////////
class TIFJEventProcessor : public TjurekAbstractEventProcessor
{
    const_daq_word_t*    input_event_data; // one event buffer
    int how_many_data_words; // how many sensible data in the buffer
    TGo4EventSourceParameter* source_of_events_ptr;   // for IFJ Kratta+Hector

public:
    TIFJEventProcessor(string name = "EBProcessor");

    void Process()
    {
        cout << "Empty TIFJEventProcessor::Process()" << endl;
        // BuildEbEvent(target) ;
    }
    //--------------------------------------------------------


    // Getting the input event from the file, or from the data stream and
    //  returning the pointer to the event
    void *   GetInputEvent() ;  // virtual  !

    void BuildEbEvent(TGo4EventSourceParameter* source_of_events, TIFJEvent* target);

    virtual ~TIFJEventProcessor() ;

    /** reading the types of events which are legal
    reading the time gates for time stamp system */
    //  bool read_in_mbs_parameters(  string nam_frs_to_hec_timestamp_diff,
    //                                string nam_ger_to_frs_timestamp_diff,
    //                                string nam_ger_to_hec_timestamp_diff);


    void postLoop();

    void remember_pointers_to_timestamped_spectra(
        spectrum_1D *  spec_ger_minus_frs_timestamp_diff,
        spectrum_1D *  spec_frs_minus_hec_timestamp_diff,
        spectrum_1D * spec_frs_minus_dgf_timestamp_diff,
        spectrum_1D * spec_ger_minus_dgf_timestamp_diff,
        spectrum_1D *spec_ger_minus_hec_timestamp_diff,
        spectrum_1D * spec_dgf_minus_hec_timestamp_diff,
        spectrum_1D  *spec_frs_minus_mib_timestamp_diff,
        spectrum_1D  *spec_ger_minus_mib_timestamp_diff);



    /** Function for unpacking the "status readout" */
    void trigger_14_block();
    /** every event has its own number (stored inside the event structure)
    To estimate the ratio of analysed event the TAnalysis class wants to
    know this number quite often */
    int * give_address_of_mbs_event_number();
    /** To have a chance to load the lookup table */
    void preLoop();

    bool read_the_gates_for_diff_spectrum(string name, int  *low, int *high);
    /** No descriptions */
    void output_statistics_events();
    /** The version for 4 branches (with miniball) of the function which
    recognizes the type of the subevent and puts it in the queue */
    bool put_curr_4subev_into_queue(TjurekMbsSubEvent* ise);
    /** reading the types of events which are legal for 4 branches mode of MBS
    reading the time gates for time stamp system */
    bool read_in_4mbs_parameters(
        string nam_ger_minus_frs_timestamp_diff,
        string nam_frs_minus_hec_timestamp_diff,

        string nam_frs_minus_dgf_timestamp_diff,
        string nam_ger_minus_dgf_timestamp_diff,

        string nam_ger_minus_hec_timestamp_diff,
        string nam_dgf_minus_hec_timestamp_diff);

    /** for debuging purposes */
    void show_n_longwords(daq_word_t *buf, int how_many);
    /** reading the types of events which are legal for 5 branches mode of MBS
    reading the time gates for time stamp system */
    bool read_in_5mbs_parameters(string nam_ger_minus_frs_timestamp_diff,
                                 string nam_frs_minus_hec_timestamp_diff,
                                 string nam_frs_minus_dgf_timestamp_diff,
                                 string nam_ger_minus_dgf_timestamp_diff,
                                 string nam_ger_minus_hec_timestamp_diff,
                                 string nam_dgf_minus_hec_timestamp_diff,
                                 string nam_frs_minus_mib_timestamp_diff,
                                 string nam_ger_minus_mib_timestamp_diff);
    /** No descriptions */
    void read_ger_synchro_group_item();
    /** No descriptions */
    void read_ger_plastic_time_lookup_data();


    void unpack_caen_v1724_kratta_digitizer( int event, int subevent, uint32_t* p_se, int length );  // Kratta

    void setup_Piotr_Pawlowski_lookup_tables(string example_data_filename);
    std::string find_proper_lookuptable_name(string ltb_name,
                                             string current_path_for_lookup_table,
                                             string data_file_name);
    vector<string>  remove_names_without_extension_ltb(vector<string>   v);
protected:
    spectrum_1D *spec_ger_minus_frs_timestamp_diff;
    spectrum_1D *spec_frs_minus_hec_timestamp_diff;
    spectrum_1D *spec_frs_minus_dgf_timestamp_diff;

    spectrum_1D *spec_ger_minus_dgf_timestamp_diff ;
    spectrum_1D *spec_ger_minus_hec_timestamp_diff;

    spectrum_1D *spec_dgf_minus_hec_timestamp_diff;  // no gates, just for information

    spectrum_1D *spec_frs_minus_mib_timestamp_diff;
    spectrum_1D *spec_ger_minus_mib_timestamp_diff ;


    //  // for 1Hz tirgger -------------------------------
    //  spectrum_1D *spec_1Hz_hec_minus_frs_timestamp_diff;
    //  spectrum_1D *spec_1Hz_hec_minus_ger_timestamp_diff;
    //  spectrum_1D *spec_1Hz_frs_minus_ger_timestamp_diff;
    //  //------------------------------------------------

    spectrum_2D *spec_synchro_xy;


    int  type_of_matching ;   // 0 = no, 1 - to the FRS, 2 - to the GER
    int  how_many_branches ;  //3= FRS GER hec     4=> FRS GER hec DGF, 5- with MIB

#ifdef NIGDY
    // flags for type 1
    bool match_frs_ger_hec_dgf ;
    bool  match_frs_ger_dgf;
    bool  match_frs_hec_dgf;
    bool  match_frs_ger_hec;

    bool    match_frs_ger ;
    bool    match_frs_dgf ;
    bool    match_frs_hec;
    bool    match_frs_when_single;     //


    // flags for type 2
    bool match_ger_frs_hec_dgf;
    bool match_ger_frs_dgf ;
    bool match_ger_hec_dgf ;

    bool    match_ger_frs;
    bool    match_ger_hec;
    bool    match_ger_dgf;
    bool    match_ger_frs_hec;
#endif

    // 5 branches, when relatively to frs ----------- ---
    bool match_frs_ger_hec_dgf_mib  ;

    // -------- 4 branches only when relatively to frs---------------------------------
    bool match_frs_ger_hec_dgf  ;
    bool match_frs_ger_hec_mib  ;
    bool match_frs_ger_dgf_mib  ;
    bool match_frs_hec_dgf_mib  ;


    // -------- 3 branches only when relatively to frs---------------------------------
    bool match_frs_ger_hec  ;
    bool match_frs_ger_dgf  ;
    bool match_frs_hec_dgf  ;
    bool match_frs_ger_mib  ;
    bool match_frs_hec_mib  ;
    bool match_frs_dgf_mib  ;


    // -------- 2 branches only ---when relatively to frs------------------------------
    bool match_frs_ger  ;
    bool match_frs_hec  ;
    bool match_frs_dgf  ;
    bool match_frs_mib  ;


    // -------- 1 branch,  ---when relatively to frs------------------------------
    // bool match_frs   ;
    bool    match_frs_when_single;     //

    //================================
    // 5 branches, when relatively to ger -------------
    //================================
    bool match_ger_frs_hec_dgf_mib  ;

    // -------- 4 branches only when relatively to ger---------------------------------
    bool match_ger_frs_hec_dgf  ;
    bool match_ger_frs_hec_mib  ;
    bool match_ger_frs_dgf_mib  ;
    bool match_ger_hec_dgf_mib  ;


    // -------- 3 branches only when relatively to ger---------------------------------
    bool match_ger_frs_hec  ;
    bool match_ger_frs_dgf  ;
    bool match_ger_hec_dgf  ;
    bool match_ger_frs_mib  ;
    bool match_ger_hec_mib  ;
    bool match_ger_dgf_mib  ;


    // -------- 2 branches only ---when relatively to ger------------------------------
    bool match_ger_frs  ;
    bool match_ger_hec  ;
    bool match_ger_dgf  ;
    bool match_ger_mib  ;


    // -------- 1 branch,  ---when relatively to ger------------------------------
    //bool match_ger  ;
    bool    match_ger_when_single ;


    // -------- NO Matching --------------------------
    //match5_frs_alone  ;
    //match5_ger_alone  ;
    //match5_hec_alone  ;
    //match5_dgf_alone  ;
    //match5_mib_alone  ;

    bool flag_accept_single_frs;
    bool flag_accept_single_ger;
    bool flag_accept_single_hec;
    bool  flag_accept_single_dgf;
    bool  flag_accept_single_mib;



    //------------------------------------------------------------
    bool collect_time_stamp_statistics_spectra;

    bool flag_ger_has_data ;

    /** putting to the right owners */
    void distribute_frs_vme_words_to_event_members(TIFJEvent *te) ;

    //  void frs_branch_tr1();
    //  void frs_branch_tr2();
    //  void frs_branch_tr3();
    //  void frs_branch_tr4();

    //  void gamma_branch1();
    //  void gamma_branch2();
    //  void gamma_branch3();
    void  swap_nr_words(short int* pointer, int how_many);

    // is true , when it was normal block, not the 1Hz trigger
    //  bool put_curr_subev_into_queue();
    //
    //  /** real matching routine */
    //  bool try_to_reconstruct_event();
    //
    //
    //  void unpack_ger_subevent(const timestamped_subevent & t );
    //  void unpack_frs_subevent(const timestamped_subevent & t );
    //  void unpack_hec_subevent(const timestamped_subevent & t );


    // is true , when it was normal block, not the 1Hz trigger
    //    bool put_curr_subev_into_queue( TGo4MbsSubEvent* ise );


    void unpack_ger_subevent(const timestamped_subevent &t, TIFJEvent* te);
    void unpack_frs_subevent(const timestamped_subevent &t, TIFJEvent* te);
    void unpack_hec_subevent(const timestamped_subevent &t, TIFJEvent* te);
    /** unpacking the DGFl subevent */
    void unpack_dgf_subevent(const timestamped_subevent & t, TIFJEvent * te);

    /** unpacking the miniball subevent */
    void unpack_mib_subevent(const timestamped_subevent & t, TIFJEvent * te);


    //   int tablica_tmp_f_g[2000] ;
    //   int tablica_tmp_f_g_h[2000] ;




    // we remember for private functions
    TIFJEvent* target_event ;
    // TjurekMbsEvent* input_event ;
    TjurekMbsSubEvent* input_subevent;

#ifdef RISING_GERMANIUMS_PRESENT
    Tlookup_table lookup ;    // lookup table for mapping the germaniums
#endif
    Tlookup_table_miniball lookup_miniball ;    // lookup table for mapping the Miniball detectors

#ifdef XIA_ELECTRONICS_FOR_GERMANIUMS_PRESENT
    // Time and Energy delivered by DGF branch must have the independent lookup tables
    Tlookup_table_doublets     lookup_xia_energies;
#endif


// Tlookup_table_kratta lookup_kratta;

//#################################################################
#if CURRENT_EXPERIMENT_TYPE==PRISMA_EXPERIMENT
//#################################################################
    vector< vector <int> > lookup_prisma;
#endif


#if CURRENT_EXPERIMENT_TYPE == G_FACTOR_OCTOBER_2005
    Tlookup_table_doublets     lookup_xia_times;  // in stoped beam is not needed
#endif

#if ( (CURRENT_EXPERIMENT_TYPE==RISING_STOPPED_BEAM_CAMPAIGN) || (CURRENT_EXPERIMENT_TYPE==RISING_ACTIVE_STOPPER_BEAM_CAMPAIGN) \
|| (CURRENT_EXPERIMENT_TYPE == RISING_ACTIVE_STOPPER_APRIL_2008) \
|| (CURRENT_EXPERIMENT_TYPE == RISING_ACTIVE_STOPPER_JULY_2008) \
|| (CURRENT_EXPERIMENT_TYPE == RISING_ACTIVE_STOPPER_100TIN ))

    Tlookup_table_doublets lookup_LR_times;
    Tlookup_table_doublets lookup_SR_times;

#if defined  ACTIVE_STOPPER_PRESENT
    Tlookup_table_triple_universal   lookup_active_stopper;

#ifdef ACTIVE_STOPPERS_HAVE_TIME_INFORMATION
    Tlookup_table_triple_universal  lookup_active_stopper_time;
#endif
#endif


#ifdef  ACTIVE_STOPPER2_PRESENT
    Tlookup_table_triple_universal   lookup_active_stopper2;
#ifdef ACTIVE_STOPPERS_HAVE_TIME_INFORMATION
    Tlookup_table_triple_universal  lookup_active_stopper2_time;
#endif
#endif

#ifdef  ACTIVE_STOPPER3_PRESENT
    Tlookup_table_triple_universal   lookup_active_stopper3;
#ifdef ACTIVE_STOPPERS_HAVE_TIME_INFORMATION
    Tlookup_table_triple_universal  lookup_active_stopper3_time;
#endif

#endif

#ifdef  POSITRON_ABSORBER_PRESENT
    Tlookup_table_triple_universal   lookup_absorber_0_1;   // comming from VME
    Tlookup_table_triple_universal   lookup_absorber_2_9;   // comming from gasiplex
    Tlookup_table_triple_universal   lookup_absorber_back_sides;   // comming from VME

    //   Tlookup_table_triple_universal   lookup_absorber_rear;
#endif

#ifdef  MUNICH_MATRIX_STRIPES_X
    //  Tlookup_table_triple_universal   lookup_stopper_matrix;
#endif


#if defined MUN_ACTIVE_STOPPER_PRESENT
    // they are separate, because come from different electronics
    Tlookup_table_triple_universal   lookup_active_stopper_x;
    Tlookup_table_triple_universal   lookup_active_stopper_y;

    vector<pair<unsigned int, unsigned int>  > fake_lookup_noise_to_neglect;

    Tlookup_table_triple_universal  lookup_multiplicity_module;
#endif




    // lookup data to read the Plastic time
    unsigned int ger_plastic_LR_time_geo;
    unsigned int ger_plastic_LR_time_channel;

#ifdef ACTIVE_STOPPERS_SECOND_AND_THIRD_HIT_IN_THE_TIME_GATE
    unsigned int ger_Silicon_LR_trigger_time_geo;
    unsigned int ger_Silicon_LR_trigger_time_channel;
#endif

    int ge_plastic_time_tray0_geo;
    int ge_plastic_time_tray0_channel;
    int ge_plastic_time_tray1_geo;
    int ge_plastic_time_tray1_channel;
    int ge_plastic_time_tray2_geo;
    int ge_plastic_time_tray2_channel;

    // kind of dummy, when new signal is comming, this will ignore warnings of the lookup table
    int ge_plastic_time_tray3_geo;
    int ge_plastic_time_tray3_channel;


    int statistics_tray0_counter;
    int statistics_tray1_counter;
    int statistics_tray2_counter;
#endif

#ifndef  __CINT__

    // for statistics, to produce the time stamp differences spectra
    vector<time_stamp_value > ger_time_stamps;
    vector<time_stamp_value > frs_time_stamps;
    vector<time_stamp_value > hec_time_stamps;
    vector<time_stamp_value > dgf_time_stamps;
    vector<time_stamp_value > mib_time_stamps;


    // real ques for subevents
    queue<timestamped_subevent > ger_subev_queue;
    queue<timestamped_subevent > frs_subev_queue;
    queue<timestamped_subevent > hec_subev_queue;
    queue<timestamped_subevent > dgf_subev_queue;
    queue<timestamped_subevent > mib_subev_queue;


#endif


    daq_word_t     vmeOne[22][32] ;
    daq_word_t     vmeUser[22][32] ;



    // --------------- matching when the reference is FRS subevent

    //string name_of_hec_to_frs_timestamp_difference_spectrum ;
    //string name_of_ger_to_frs_timestamp_difference_spectrum ;


    int down_ger_minus_frs_gate ;
    int up_ger_minus_frs_gate ;

    int down_hec_minus_frs_gate ;
    int up_hec_minus_frs_gate ;

    int down_dgf_minus_frs_gate ;
    int up_dgf_minus_frs_gate ;

    int down_mib_minus_frs_gate ;
    int up_mib_minus_frs_gate ;

    bool ger_is_in_frs_gate()
    {
        if(frs_subev_queue.empty() || ger_subev_queue.empty())
        {
            //cout << "one of frs/ger que is empty, so return false " <<  endl;
            return false ;
        }

        long long diff = ger_subev_queue.front() - frs_subev_queue.front() ;
        //       cout << "ques are not empty and diff (ger-frs) = " << diff
        //             << " while gate is "
        //             <<  down_ger_minus_frs_gate << " : "
        //             << up_ger_minus_frs_gate <<  endl;

        return (diff >= down_ger_minus_frs_gate) && (diff <= up_ger_minus_frs_gate) ;
    }

    bool hec_is_in_frs_gate()
    {
        if(frs_subev_queue.empty() || hec_subev_queue.empty())
        {
            //         if (frs_subev_queue.empty())cout << "Que frs_subev is empty " << endl ;
            //         if (hec_subev_queue.empty())cout << "Que hec_subev is empty " << endl ;
            return false ;
        }
        long long diff = hec_subev_queue.front() - frs_subev_queue.front() ;
        //       cout << "diff hec - frs = " << diff << endl;
        return (diff >= down_hec_minus_frs_gate) && (diff <= up_hec_minus_frs_gate) ;
    }
    //-----------------------------------------------
    bool dgf_is_in_frs_gate()
    {
        if(frs_subev_queue.empty() || dgf_subev_queue.empty())
        {
            //         if (frs_subev_queue.empty())cout << "Que frs_subev is empty " << endl ;
            //         if (dgf_subev_queue.empty())cout << "Que dgf_subev is empty " << endl ;
            return false ;
        }
        long long diff = dgf_subev_queue.front() - frs_subev_queue.front() ;
        //       cout << "diff hec - frs = " << diff << endl;
        return (diff >= down_dgf_minus_frs_gate) && (diff <= up_dgf_minus_frs_gate) ;
    }


    //-----------------------------------------------
    bool mib_is_in_frs_gate()
    {
        if(frs_subev_queue.empty() || mib_subev_queue.empty())
        {
            //         if (frs_subev_queue.empty())cout << "Que frs_subev is empty " << endl ;
            //         if (mib_subev_queue.empty())cout << "Que mib_subev is empty " << endl ;
            return false ;
        }
        long long diff = mib_subev_queue.front() - frs_subev_queue.front() ;
        //       cout << "diff mib - frs = " << diff << endl;
        return (diff >= down_mib_minus_frs_gate) && (diff <= up_mib_minus_frs_gate) ;
    }

    //============================================================

    //------------------------------------------
    bool ger_too_old_for_frs()
    {
        if(frs_subev_queue.empty() || ger_subev_queue.empty()) return false ;

        long long diff = ger_subev_queue.front() - frs_subev_queue.front() ;
        return (diff < down_ger_minus_frs_gate);
    }
    //---------------------------------------------
    bool hec_too_old_for_frs()
    {
        if(frs_subev_queue.empty() || hec_subev_queue.empty()) return false ;

        long long diff = hec_subev_queue.front() - frs_subev_queue.front() ;
        return (diff < down_hec_minus_frs_gate);
    }

    //---------------------------------------------
    bool dgf_too_old_for_frs()
    {
        if(frs_subev_queue.empty() || dgf_subev_queue.empty()) return false ;

        long long diff = dgf_subev_queue.front() - frs_subev_queue.front() ;
        return (diff < down_dgf_minus_frs_gate);
    }

    //---------------------------------------------
    bool mib_too_old_for_frs()
    {
        if(frs_subev_queue.empty() || mib_subev_queue.empty()) return false ;

        long long diff = mib_subev_queue.front() - frs_subev_queue.front() ;
        return (diff < down_mib_minus_frs_gate);
    }

    //==============================================================
    // to the matching when the reference is GER===============================
    //==============================================================


    /** event nr taken from the mbs event structure */
    int current_ev_nr;

    int down_frs_minus_ger_gate ;
    int up_frs_minus_ger_gate ;

    int down_hec_minus_ger_gate ;
    int up_hec_minus_ger_gate ;

    int down_dgf_minus_ger_gate ;
    int up_dgf_minus_ger_gate ;

    int down_mib_minus_ger_gate ;
    int up_mib_minus_ger_gate ;

    bool frs_is_in_ger_gate()
    {
        if(ger_subev_queue.empty() || frs_subev_queue.empty()) return false ;

        long long diff = frs_subev_queue.front() - ger_subev_queue.front() ;
        return (diff >= down_frs_minus_ger_gate) && (diff <= up_frs_minus_ger_gate) ;
    }
    //--------------------------------------------------
    bool hec_is_in_ger_gate()
    {
        if(ger_subev_queue.empty() || hec_subev_queue.empty()) return false ;

        long long diff = hec_subev_queue.front() - ger_subev_queue.front() ;
        return (diff >= down_hec_minus_ger_gate) && (diff <= up_hec_minus_ger_gate) ;
    }

    //--------------------------------------------------
    bool dgf_is_in_ger_gate()
    {
        if(ger_subev_queue.empty() || dgf_subev_queue.empty()) return false ;

        long long diff = dgf_subev_queue.front() - ger_subev_queue.front() ;
        return (diff >= down_dgf_minus_ger_gate) && (diff <= up_dgf_minus_ger_gate) ;
    }

    //--------------------------------------------------
    bool mib_is_in_ger_gate()
    {
        if(ger_subev_queue.empty() || mib_subev_queue.empty()) return false ;

        long long diff = mib_subev_queue.front() - ger_subev_queue.front() ;
        return (diff >= down_mib_minus_ger_gate) && (diff <= up_mib_minus_ger_gate) ;
    }

    //--------------------------------------------------
    //==============================================================
    //--------------------------------------------------
    bool frs_too_old_for_ger()
    {
        if(ger_subev_queue.empty() || frs_subev_queue.empty()) return false ;

        long long diff = frs_subev_queue.front() - ger_subev_queue.front() ;
        return (diff < down_frs_minus_ger_gate);
    }
    //--------------------------------------------------
    bool hec_too_old_for_ger()
    {
        if(ger_subev_queue.empty() || hec_subev_queue.empty()) return false ;

        long long diff = hec_subev_queue.front() - ger_subev_queue.front() ;
        return (diff < down_hec_minus_ger_gate);
    }
    //--------------------------------------------------
    bool dgf_too_old_for_ger()
    {
        if(ger_subev_queue.empty() || dgf_subev_queue.empty()) return false ;

        long long diff = dgf_subev_queue.front() - ger_subev_queue.front() ;
        return (diff < down_dgf_minus_ger_gate);
    }
    //--------------------------------------------------
    bool mib_too_old_for_ger()
    {
        if(ger_subev_queue.empty() || mib_subev_queue.empty()) return false ;

        long long diff = mib_subev_queue.front() - ger_subev_queue.front() ;
        return (diff < down_mib_minus_ger_gate);
    }
    //--------------------------------------------------
    /** making the report of the timestamped subevent matching
       when the matching is made to the GER subevent */
    void make_report_ger_style();
    /** making the report of the timestamped subevent matching
       when the matching is made to the FRS subevent */
    void make_report_frs_style();

    /** When one of the 3 timestamps que is full, we make report and clean them all */
    void queue_full_make_timestamp_spectra();
    /** No descriptions */
    bool chaeck_for_1Hz_marker(TjurekMbsSubEvent* ise);

    // statistics
    //
    int frs_subevents,
        ger_subevents,
        hec_subevents ,
        dgf_subevents,
        mib_subevents; // what came

#if ((CURRENT_EXPERIMENT_TYPE == RISING_STOPPED_BEAM_CAMPAIGN) ||         (CURRENT_EXPERIMENT_TYPE == RISING_ACTIVE_STOPPER_BEAM_CAMPAIGN) \
|| (CURRENT_EXPERIMENT_TYPE == RISING_ACTIVE_STOPPER_APRIL_2008) \
|| (CURRENT_EXPERIMENT_TYPE == RISING_ACTIVE_STOPPER_JULY_2008) \
|| (CURRENT_EXPERIMENT_TYPE == RISING_ACTIVE_STOPPER_100TIN ))


    int  frs_user_subevents, time_subevents;
#endif


    int unknown_type_subevents ;
    int zero_type_subevents ;


    int frs_hec_dgf_event,
        frs_ger_dgf_event,
        frs_ger_hec_dgf_event ;

    int frs_hec_event,
        frs_dgf_event,
        frs_ger_event,
        frs_ger_hec_event ;

    int ger_hec_dgf_event,
        ger_frs_dgf_event,
        ger_frs_hec_dgf_event ;
    int ger_hec_event,
        ger_dgf_event,
        ger_frs_event,
        ger_frs_hec_event ;

    int ger_matched_single_event,
        frs_matched_single_event;

    // not matched
    int ger_orphan,
        hec_orphan,
        frs_orphan,
        dgf_orphan,
        mib_orphan ;

    int ger_empty ;


    int
    counter_valid,
    counter_put,
    counter_try,
    counter_total,
    counter_nonsense;
    /** The same GER subevent can contain pulser and physics information.
    Here we will mark if there is physics  */
    bool germanium_data_event;
    int ger_pulser , ger_physics, ger_physics_empty ; // for quality check

    bool flag_old_style_pulser_in_b7 ; // during commisioninig experiment
    bool CheckForGerData(const daq_word_t* data, int length);

    long long time_stamp_beg_of_last_spill ;

    /** No descriptions */
    void perhaps_one_queue_is_too_big();

    bool need_FRS;
    bool need_HEC;
    bool need_GER;
    bool need_DGF;
    bool need_MIB;

    /** No descriptions */

    // what_to_do
    int matching_to_FRS(TIFJEvent *te ,
                        bool flag_frs, bool flag_hec, bool flag_dgf, bool flag_mib);
    int matching_to_GER(TIFJEvent *te ,
                        bool flag_ger, bool flag_hec, bool flag_dgf, bool flag_mib);


    /**  */
    unsigned int ger_synchro_vxi_crate1_group;
    unsigned int ger_synchro_vxi_crate1_item;
    unsigned int ger_synchro_vxi_crate2_group;
    unsigned int ger_synchro_vxi_crate2_item;

    // instead the above counters, now they are collected into the array
    int event_combination[32] ;  // 2**5 (branches) = 32 ;
    /** Reconstruction of the event in case of 5 branches (5 types of subevents: FRS, GER, HEC, DGF, MIN) */
    bool try_to_5reconstruct_event(TIFJEvent * te);


    //
    vector<frs_signal> frsOne_lookup_table;
    void read_frsOne_lookup_table();
    bool frsOne_lookup_should_be_loaded;

    vector<frs_signal> frsUser_lookup_table;
    void read_frsUser_lookup_table();
    bool frsUser_lookup_should_be_loaded;

    /** This is the function which reads new style of event - characteristic
    to the fast beam campaign. There is no timestamp matching, everything
    comes together as one event (with subevent parts) */
    bool unpack_the_CCB_event();
    //bool unpack_the_kratta_mbs_event();
    bool  unpack_kratta_hector_event(const_daq_word_t *data, int how_many_words);


    void unpack_trigger_pattern( int event, int subevent, uint32_t* data, int length );
    void unpack_36_2800( int event, int subevent, uint32_t* data, int length );
    void unpack_10_1( int event, int subevent, uint32_t* data, int length );
    void unpack_34_1( int event, int subevent, uint32_t* data, int length );
    void unpack_36_2700( int event, int subevent, uint32_t* data, int length );
    void unpack_32_1130( int event, int subevent, uint32_t* data, int length ) ;
    void unpack_36_9494( int event, int subevent, uint32_t* data, int length );
    // second argument is telling if we unpack real hector data, or foswitch data
    // which is comming with the same structure, (but later) in the event
    void unpack_ccb_non_kratta_z_metryczkami(uint32_t *data_block, bool real_hector, int length);
    uint32_t     swap_int32(uint32_t   dana);
//*****************************************************************************



    bool unpack_timing_module_subevent(
        const daq_word_t*  long_data,
        int how_many_words);

    bool unpack_munich_timing_module_subevent(
        const daq_word_t*  long_data,
        int how_many_words);

    /** This function is unpacking not from the timestamped subevent, but just directly
    from the MBS data block  */
    bool unpack_pisolo_event(const daq_word_t *data, int how_many_words);
    bool unpack_OLD_pisolo_event(const daq_word_t *data, int how_many_words);
    bool unpack_exotic_event_from_raw_array(const daq_word_t *data, int how_many_words);
    bool unpack_active_stopper_subevent_from_raw_array(const_daq_word_t *data, int how_many_words);
    bool unpack_prisma_event(const daq_word_t *data, int how_many_words);

    bool unpack_munich_sam3_subevent_from_raw_array(const_daq_word_t *data, int how_many_words);

    /** This function is unpacking not from the timestamped subevent, but just directly
    from the MBS data block */
    template <typename typ>
    bool unpack_dgf_subevent_from_raw_array(typ * data, int how_many_words);

#ifdef NIGDY
    /** This function is unpacking not from the timestamped subevent, but just directly
    from the MBS data block */
    bool unpack_dgf_subevent_from_raw_array(const daq_word_t * data, int how_many_words);
    // OVERLOADING !!!!!
    /** This function is unpacking not from the timestamped subevent, but just directly
    from the MBS data block */
    bool unpack_dgf_subevent_from_raw_array(const unsigned short * data, int how_many_words);
#endif // NIGDY



    /** This function is unpacking not from the timestamped subevent, but just directly
    from the MBS data block */
    bool unpack_frsUser_subevent_from_raw_array(const daq_word_t * data, int how_many_words);

    bool flag_vmeOne_zeroing_needed ; // to zeroin before frs  unpacking function
    bool flag_vmeUser_zeroing_needed ; // to zeroin before  frs_user unpacking function

    int minimal(int a, int b)
    {
        return a < b ? a : b;
    }
    unsigned int minimal(unsigned int a, unsigned int b)
    {
        return a < b ? a : b;
    }

    int maximal(int a, int b)
    {
        return a > b ? a : b;
    }
    unsigned int maximal(unsigned int a, unsigned int b)
    {
        return a > b ? a : b;
    }


    // kind of notebook to  remember the pointers of the time information which
    // have to be subtracted with "plastic" time (see more explanations in the text)
    vector<pair<int, int*> > to_subtract_reference_time;


    int decode_munich_absorber_data(const daq_word_t * data, const uint sim_stop_word);
    void read_munich_lookup();

    bool
    unpack_multi_hit_tdc_v1290_from_raw_array(const_daq_word_t *data, int how_many_words);

#if  (CURRENT_EXPERIMENT_TYPE == RISING_ACTIVE_STOPPER_JULY_2008)
    bool unpack_procid45_v767_and_775(
        const daq_word_t*  long_data,
        int how_many_words);
#endif

int HECTOR_ADC_GEO;
int HECTOR_TDC_GEO;
int PHOSWITCH_ADC_GEO = 20;  // data will be taken from lookup table (finally)
int PHOSWITCH_TDC_GEO = 21;


void unpack_V775(Tvisitcard *visit_ptr);
void unpack_V879_878(Tvisitcard *visit_ptr);
void unpack_V785(Tvisitcard *visit_ptr);
void unpack_V830(Tvisitcard *visit_ptr);
void unpack_V1190(Tvisitcard *visit_ptr);
void unpack_V2740(Tvisitcard *visit_ptr);

//  ClassDef(TIFJEventProcessor,1)
};

////////////////////////////////////////////////////////////////////////////
#endif //TEBEVENTPROCESSOR_H
